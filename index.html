<!DOCTYPE html>
<html lang="en">
<script src="https://unpkg.com/@supabase/supabase-js@2"></script>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, interactive-widget=resizes-content" />
    <title>Tube Jump: Mind the Gap</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=P22+Underground:wght@700&display=swap" rel="stylesheet"> 
    <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap" rel="stylesheet">
    
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
      body {
        font-family: 'Inter', sans-serif;
        background-color: #050505;
        overflow: hidden; /* Prevent scrolling on mobile */
        touch-action: none; /* Prevent browser zooming/scrolling */
        user-select: none;
        -webkit-user-select: none;
      }
      .pixel-art {
        image-rendering: pixelated;
      }
      /* Custom scrollbar for shop */
      ::-webkit-scrollbar {
        width: 8px;
      }
      ::-webkit-scrollbar-track {
        background: #1f2937; 
      }
      ::-webkit-scrollbar-thumb {
        background: #4b5563; 
        border-radius: 4px;
      }
      ::-webkit-scrollbar-thumb:hover {
        background: #6b7280; 
      }
      /* Johnston-like font fallback */
      .font-tube {
        font-family: 'P22 Underground', 'Inter', sans-serif;
      }
      .font-mono-receipt {
        font-family: 'Share Tech Mono', monospace;
      }
      
      @keyframes pop {
        0% { transform: scale(1); }
        50% { transform: scale(1.3); }
        100% { transform: scale(1); }
      }
      .animate-pop {
        animation: pop 0.2s ease-out;
      }

      @keyframes fadeInSlow {
        0% { opacity: 0; transform: scale(0.95); }
        100% { opacity: 1; transform: scale(1); }
      }
      .animate-fadeInSlow {
        animation: fadeInSlow 1.2s cubic-bezier(0.16, 1, 0.3, 1) forwards;
      }
      
      @keyframes fadeIn {
        0% { opacity: 0; }
        100% { opacity: 1; }
      }
      .animate-fade-in {
        animation: fadeIn 0.5s ease-out forwards;
      }

      @keyframes pulseRed {
        0%, 100% { background-color: rgba(20, 0, 0, 0.95); color: #E32017; }
        50% { background-color: rgba(60, 0, 0, 0.95); color: #ff5555; }
      }
      .animate-pulse-red {
        animation: pulseRed 2s infinite ease-in-out;
      }
      
      .dot-matrix-text {
          font-family: 'Share Tech Mono', monospace;
          color: #FFB81C;
          text-shadow: 0 0 2px #FF9900;
      }

    </style>
<script type="importmap">
{
  "imports": {
    "react": "https://aistudiocdn.com/react@^19.2.0",
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.2.0/",
    "react/": "https://aistudiocdn.com/react@^19.2.0/"
  }
}
</script>
</head>
  <body>
    <div id="root"></div>

    <script type="text/babel">
      const { useState, useRef, useEffect, useCallback } = React;

// --- SUPABASE START ---
      const SUPABASE_URL = 'https://pyxjaingrqsfyqcidblw.supabase.co';
      const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InB5eGphaW5ncnFzZnlxY2lkYmx3Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjM3Mjk5MjEsImV4cCI6MjA3OTMwNTkyMX0.RIWfK5ngpNSfW67OS7av_L1P6rSAustabdWjj7OQow0';
      const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);
      // ----------------------

      // --- CONSTANTS ---
      const CANVAS_WIDTH = 400;
      const CANVAS_HEIGHT = 600;

      const GRAVITY = 0.4;
      const JUMP_FORCE = -11;
      const SPRING_FORCE = -22; 
      const JETPACK_SPEED = -15; 
      const ROCKET_START_SPEED = -25;
      const MOVEMENT_SPEED = 6;
      const MAX_FALL_SPEED = 12;

      const PLAYER_WIDTH = 40;
      const PLAYER_HEIGHT = 40;

      const PLATFORM_WIDTH = 70;
      const PLATFORM_HEIGHT = 16;
      const PLATFORM_GAP_MIN = 40;
      const PLATFORM_GAP_MAX = 120;

      // Zones
      const ZONE_LIMITS = {
          TUBE: 5000, 
          STATION: 10000, // Zone 2 ends/City starts
          CITY: 25000,    // Zone 3 ends/Space starts
          SPACE: 25000
      };

      // Colors (London Underground Palette)
      const COLORS = {
        RED: '#E32017',    // Central Line
        BLUE: '#003688',   // Piccadilly Line
        YELLOW: '#FFD300', // Safety line
        GREY: '#A0A5A9',   // Jubilee / Platform
        DARK: '#111111',   // Tunnel background
        STATION_BG: '#E5E5E5', // Station Tiling
        CITY_BG: '#87CEEB', // London Day (Sky Blue)
        SPACE_BG: '#050314', // Deep Space
        WHITE: '#FFFFFF',
        BROWN: '#B06010',  // Bakerloo
        GREEN: '#009900',  // District / Spring
        PURPLE: '#9B0056', // Elizabeth Line (Jetpack)
        ORANGE: '#FF7F00', // Fire/Sparks
        GOLD: '#FFD700',   // Coins
        MAGNET: '#D32F2F', // Magnet Red
        DTUP_BLUE: '#0019a8', // Siemens Inspiro Skirt
        DTUP_WHITE: '#F0F0F0', // Siemens Inspiro Body
        GHOST: '#783F04',  // Brick color
        ESCALATOR: '#222222', // Escalator dark
        NORTHERN: '#000000',
        VICTORIA: '#0098D4',
        METROPOLITAN: '#9B0056'
      };

      // --- TYPES ---
      const PlatformType = {
        STATIC: 'STATIC',
        MOVING: 'MOVING',
        BREAKABLE: 'BREAKABLE',
        GHOST: 'GHOST',
        CONVEYOR: 'CONVEYOR'
      };

      const PowerupType = {
        NONE: 'NONE',
        SPRING: 'SPRING',
        JETPACK: 'JETPACK',
        MAGNET: 'MAGNET'
      };

      const GameState = {
        SPLASH: 'SPLASH',
        INTRO: 'INTRO',
        NAME_INPUT: 'NAME_INPUT',
        START: 'START',
        PLAYING: 'PLAYING',
        TERMINATED_ANIM: 'TERMINATED_ANIM', 
        GAME_OVER: 'GAME_OVER',
        SHOP: 'SHOP',
        MISSIONS: 'MISSIONS',
        SETTINGS: 'SETTINGS',
        RANKING: 'RANKING'
      };

      const SkinType = {
        NONE: 'NONE',
        HARDHAT: 'HARDHAT',
        TOPHAT: 'TOPHAT',
        VIKING: 'VIKING',
        ROYALGUARD: 'ROYALGUARD',
        CROWN: 'CROWN'
      };

      const ConsumableType = {
        ROCKET: 'ROCKET',
        REVIVE: 'REVIVE',
        DOUBLE_COINS: 'DOUBLE_COINS',
        LUCKY_CHARM: 'LUCKY_CHARM'
      };

      const MissionCategory = {
        HEIGHT: 'HEIGHT',
        COINS: 'COINS',
        JUMPS: 'JUMPS',
        POWERUPS: 'POWERUPS',
        GAMES: 'GAMES',
        STOPS: 'STOPS'
      };

      const SHOP_SKINS = [
        { id: SkinType.NONE, name: 'Default', price: 0, desc: 'Classic Tube style.' },
        { id: SkinType.HARDHAT, name: 'Hard Hat', price: 50, desc: 'Safety first!', color: '#FBBF24' },
        { id: SkinType.TOPHAT, name: 'Top Hat', price: 300, desc: 'Quite fancy.', color: '#000' },
        { id: SkinType.VIKING, name: 'Viking', price: 500, desc: 'To Valhalla!', color: '#A4A4A4' },
        { id: SkinType.ROYALGUARD, name: 'Royal Guard', price: 1000, desc: 'Stand attention!', color: '#000' },
        { id: SkinType.CROWN, name: 'Royal Crown', price: 5000, desc: 'King of the Underground.', color: '#FFD700' },
      ];

      const SHOP_CONSUMABLES = [
        { id: ConsumableType.ROCKET, name: 'Rocket Start', price: 200, desc: 'Start at 2000m!', icon: 'üöÄ' },
        { id: ConsumableType.REVIVE, name: 'Extra Life', price: 500, desc: 'Saves you once.', icon: '‚ù§Ô∏è' },
        { id: ConsumableType.DOUBLE_COINS, name: 'Double Coins', price: 400, desc: '2x Coins next run!', icon: 'ü™ô' },
        { id: ConsumableType.LUCKY_CHARM, name: 'Lucky Charm', price: 300, desc: 'More powerups!', icon: 'üçÄ' }
      ];

      // Tiered Mission Definitions (5 Tiers)
      const MISSION_DEFINITIONS = {
          [MissionCategory.HEIGHT]: [
              { target: 5000, reward: 50, desc: "Reach Station Zone (5000)" },
              { target: 10000, reward: 100, desc: "Reach City Zone (10000)" },
              { target: 25000, reward: 250, desc: "Reach Space (25000)" },
              { target: 50000, reward: 1000, desc: "Deep Space (50000)" },
              { target: 100000, reward: 2500, desc: "Reach Infinity (100000)" }
          ],
          [MissionCategory.COINS]: [
              { target: 200, reward: 50, desc: "Accumulate 200 Coins" },
              { target: 1000, reward: 250, desc: "Accumulate 1000 Coins" },
              { target: 5000, reward: 800, desc: "Accumulate 5000 Coins" },
              { target: 20000, reward: 3000, desc: "Accumulate 20000 Coins" },
              { target: 50000, reward: 8000, desc: "Accumulate 50000 Coins" }
          ],
          [MissionCategory.JUMPS]: [
              { target: 500, reward: 100, desc: "Jump 500 Times" },
              { target: 2500, reward: 400, desc: "Jump 2500 Times" },
              { target: 10000, reward: 1000, desc: "Jump 10000 Times" },
              { target: 50000, reward: 4000, desc: "Jump 50000 Times" },
              { target: 100000, reward: 10000, desc: "Jump 100000 Times" }
          ],
          [MissionCategory.POWERUPS]: [
              { target: 20, reward: 100, desc: "Collect 20 Powerups" },
              { target: 100, reward: 400, desc: "Collect 100 Powerups" },
              { target: 500, reward: 1200, desc: "Collect 500 Powerups" },
              { target: 2000, reward: 3500, desc: "Collect 2000 Powerups" },
              { target: 5000, reward: 10000, desc: "Collect 5000 Powerups" }
          ],
          [MissionCategory.GAMES]: [
              { target: 10, reward: 100, desc: "Play 10 Games" },
              { target: 50, reward: 400, desc: "Play 50 Games" },
              { target: 200, reward: 1000, desc: "Play 200 Games" },
              { target: 1000, reward: 5000, desc: "Play 1000 Games" },
              { target: 5000, reward: 15000, desc: "Play 5000 Games" }
          ],
          [MissionCategory.STOPS]: [
              { target: 50, reward: 50, desc: "Land on 50 Platforms" },
              { target: 250, reward: 250, desc: "Land on 250 Platforms" },
              { target: 1000, reward: 800, desc: "Land on 1000 Platforms" },
              { target: 5000, reward: 2500, desc: "Land on 5000 Platforms" },
              { target: 20000, reward: 10000, desc: "Land on 20000 Platforms" }
          ]
      };

      // TRANSLATIONS
      const TRANSLATIONS = {
          EN: {
              PLAY: "PLAY",
              SHOP: "SHOP",
              TASKS: "TASKS",
              SETTINGS: "SETTINGS",
              HEIGHT: "HEIGHT",
              BEST: "BEST",
              SCORE: "Score",
              COINS: "Coins",
              OWNED: "OWNED",
              BUY: "BUY",
              EQUIP: "EQUIP",
              EQUIPPED: "EQUIPPED",
              BACK: "BACK TO PLATFORM",
              TRY_AGAIN: "TRY AGAIN",
              EXIT: "EXIT",
              SERVICE_TASKS: "SERVICE TASKS",
              TICKET_HALL: "TICKET HALL",
              SKINS: "SKINS",
              ITEMS: "ITEMS",
              MASTERY: "MASTERY",
              ALL_DONE: "ALL TIERS COMPLETED",
              REWARD: "REWARD",
              CLAIM: "CLAIM",
              IN_PROGRESS: "IN PROGRESS",
              GAME_OVER_TITLE: "SERVICE TERMINATED",
              GAME_OVER_DESC: "Mind the Gap",
              SERVICE_TERMINATED: "SERVICE\nTERMINATED",
              ENTER_STATION: "Click to Enter Station",
              LANGUAGE: "LANGUAGE",
              STATS: "STATISTICS",
              STAT_HEIGHT: "Total Height",
              STAT_COINS: "Total Coins",
              STAT_JUMPS: "Total Jumps",
              STAT_GAMES: "Total Games",
              STAT_POWERUPS: "Powerups",
              SERVICE_STATUS: "SERVICE STATUS",
              GOOD_SERVICE: "Good Service",
              LINE: "Line",
              DETAILS: "Details",
              IDENTIFICATION: "IDENTIFICATION",
              ENTER_NAME: "ENTER NAME",
              CONFIRM: "CONFIRM",
              RANKING: "RANKING",
              TOP_PASSENGERS: "PASSENGER RANKING",
              SYNCING: "Checking manifest...",
              NO_DATA: "No passenger data found.",
              PLATFORM: "PLATFORM",
              DESTINATION: "DESTINATION",
              TIME: "TIME",
              DISPLAY: "DISPLAY",
              AUDIO: "AUDIO",
              SOUND: "Sound",
              FULLSCREEN: "TOGGLE FULLSCREEN",
              FS_NOTE: "Note: iOS users please use 'Add to Home Screen'."
          },
          DE: {
              PLAY: "START",
              SHOP: "SHOP",
              TASKS: "MISSIONEN",
              SETTINGS: "OPTIONEN",
              HEIGHT: "H√ñHE",
              BEST: "BESTE",
              SCORE: "Punkte",
              COINS: "M√ºnzen",
              OWNED: "BESITZ",
              BUY: "KAUFEN",
              EQUIP: "AUSR√úSTEN",
              EQUIPPED: "AUSGER√úSTET",
              BACK: "ZUR√úCK ZUM GLEIS",
              TRY_AGAIN: "NEUSTART",
              EXIT: "BEENDEN",
              SERVICE_TASKS: "AUFGABEN",
              TICKET_HALL: "FAHRKARTEN",
              SKINS: "OUTFITS",
              ITEMS: "ITEMS",
              MASTERY: "MEISTERSCHAFT",
              ALL_DONE: "ALLE STUFEN ERLEDIGT",
              REWARD: "BELOHNUNG",
              CLAIM: "ABHOLEN",
              IN_PROGRESS: "LAUFEND",
              GAME_OVER_TITLE: "BETRIEB EINGESTELLT",
              GAME_OVER_DESC: "Bitte Zur√ºckbleiben",
              SERVICE_TERMINATED: "BETRIEB\nEINGESTELLT",
              ENTER_STATION: "Klicken zum Starten",
              LANGUAGE: "SPRACHE",
              STATS: "STATISTIKEN",
              STAT_HEIGHT: "Gesamth√∂he",
              STAT_COINS: "Gesamtm√ºnzen",
              STAT_JUMPS: "Spr√ºnge Gesamt",
              STAT_GAMES: "Gespielte Runden",
              STAT_POWERUPS: "Powerups",
              SERVICE_STATUS: "BETRIEBSSTATUS",
              GOOD_SERVICE: "Guter Service",
              LINE: "Linie",
              DETAILS: "Details",
              IDENTIFICATION: "IDENTIFIKATION",
              ENTER_NAME: "NAME EINGEBEN",
              CONFIRM: "BEST√ÑTIGEN",
              RANKING: "RANGLISTE",
              TOP_PASSENGERS: "FAHRGAST RANGLISTE",
              SYNCING: "Lade Liste...",
              NO_DATA: "Keine Daten gefunden.",
              PLATFORM: "GLEIS",
              DESTINATION: "ZIEL",
              TIME: "ZEIT",
              DISPLAY: "BILDSCHIRM",
              AUDIO: "TON",
              SOUND: "Ger√§usche",
              FULLSCREEN: "VOLLBILD UMSCHALTEN",
              FS_NOTE: "iOS: Bitte 'Zum Home-Bildschirm' nutzen."
          }
      };

      // --- AUDIO MANAGER ---
      const AudioSys = {
        ctx: null,
        isMuted: false,
        jetpackNode: null,
        noiseBuffer: null,

        init: function() {
          try {
            if (!this.ctx) {
              const AudioContext = window.AudioContext || window.webkitAudioContext;
              this.ctx = new AudioContext();
              this.createNoiseBuffer();
            }
            if (this.ctx.state === 'suspended') {
              this.ctx.resume();
            }
          } catch(e) {
            console.warn("Audio init failed", e);
          }
        },

        createNoiseBuffer: function() {
            if (!this.ctx) return;
            const bufferSize = this.ctx.sampleRate * 2; 
            const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                data[i] = Math.random() * 2 - 1;
            }
            this.noiseBuffer = buffer;
        },

        playTone: function(freq, type, duration, vol = 0.1) {
          if (this.isMuted || !this.ctx) return;
          try {
              const osc = this.ctx.createOscillator();
              const gain = this.ctx.createGain();
              osc.type = type;
              osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
              gain.gain.setValueAtTime(vol, this.ctx.currentTime);
              gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
              osc.connect(gain);
              gain.connect(this.ctx.destination);
              osc.start();
              osc.stop(this.ctx.currentTime + duration);
          } catch(e) {}
        },

        playIntroSequence: function() {
            if (this.isMuted || !this.ctx) return;
            try {
                const t = this.ctx.currentTime;
                if (!this.noiseBuffer) this.createNoiseBuffer();

                const wind = this.ctx.createBufferSource();
                wind.buffer = this.noiseBuffer;
                const windFilter = this.ctx.createBiquadFilter();
                windFilter.type = 'lowpass';
                windFilter.frequency.setValueAtTime(100, t);
                windFilter.frequency.linearRampToValueAtTime(300, t + 2);
                const windGain = this.ctx.createGain();
                windGain.gain.setValueAtTime(0, t);
                windGain.gain.linearRampToValueAtTime(0.8, t + 1);
                windGain.gain.linearRampToValueAtTime(0, t + 3);
                wind.connect(windFilter); windFilter.connect(windGain); windGain.connect(this.ctx.destination);
                wind.start(t);

                const chime = this.ctx.createOscillator();
                chime.type = 'sine';
                chime.frequency.setValueAtTime(660, t + 3.2); 
                const chimeGain = this.ctx.createGain();
                chimeGain.gain.setValueAtTime(0, t + 3.2);
                chimeGain.gain.linearRampToValueAtTime(0.1, t + 3.25);
                chimeGain.gain.exponentialRampToValueAtTime(0.001, t + 4.0);
                chime.connect(chimeGain); chimeGain.connect(this.ctx.destination);
                chime.start(t + 3.2); chime.stop(t + 4.0);

                const chime2 = this.ctx.createOscillator();
                chime2.type = 'sine';
                chime2.frequency.setValueAtTime(523.25, t + 3.6); 
                const chime2Gain = this.ctx.createGain();
                chime2Gain.gain.setValueAtTime(0, t + 3.6);
                chime2Gain.gain.linearRampToValueAtTime(0.1, t + 3.65);
                chime2Gain.gain.exponentialRampToValueAtTime(0.001, t + 4.4);
                chime2.connect(chime2Gain); chime2Gain.connect(this.ctx.destination);
                chime2.start(t + 3.6); chime2.stop(t + 4.4);
            } catch(e) {}
        },

        jump: function() {
          if (this.isMuted || !this.ctx) return;
          try {
              const osc = this.ctx.createOscillator();
              const gain = this.ctx.createGain();
              osc.frequency.setValueAtTime(150, this.ctx.currentTime);
              osc.frequency.linearRampToValueAtTime(300, this.ctx.currentTime + 0.1);
              gain.gain.setValueAtTime(0.05, this.ctx.currentTime);
              gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.1);
              osc.connect(gain);
              gain.connect(this.ctx.destination);
              osc.start();
              osc.stop(this.ctx.currentTime + 0.1);
          } catch(e) {}
        },

        spring: function() {
          if (this.isMuted || !this.ctx) return;
          try {
              const osc = this.ctx.createOscillator();
              const gain = this.ctx.createGain();
              osc.type = 'sine';
              osc.frequency.setValueAtTime(100, this.ctx.currentTime);
              osc.frequency.exponentialRampToValueAtTime(600, this.ctx.currentTime + 0.4);
              gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
              gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.4);
              osc.connect(gain);
              gain.connect(this.ctx.destination);
              osc.start();
              osc.stop(this.ctx.currentTime + 0.4);
          } catch(e) {}
        },

        coin: function() {
          if (this.isMuted || !this.ctx) return;
          this.playTone(1200, 'sine', 0.1, 0.05);
          setTimeout(() => this.playTone(1800, 'sine', 0.2, 0.05), 50);
        },

        magnet: function() {
          if (this.isMuted || !this.ctx) return;
          try {
              const t = this.ctx.currentTime;
              const freqs = [1046, 1318, 1568, 2093]; 
              freqs.forEach((f, i) => {
                 const osc = this.ctx.createOscillator();
                 const g = this.ctx.createGain();
                 osc.type = 'sine';
                 osc.frequency.setValueAtTime(f, t + i*0.04);
                 g.gain.setValueAtTime(0.03, t + i*0.04);
                 g.gain.exponentialRampToValueAtTime(0.001, t + i*0.04 + 0.4);
                 osc.connect(g); g.connect(this.ctx.destination);
                 osc.start(t + i*0.04); osc.stop(t + i*0.04 + 0.4);
              });
          } catch(e) {}
        },

        crash: function() {
          if (this.isMuted || !this.ctx) return;
          this.playTone(80, 'sawtooth', 0.2, 0.1);
        },
        
        revive: function() {
          if (this.isMuted || !this.ctx) return;
          try {
              const t = this.ctx.currentTime;
              const freqs = [523, 659, 783, 1046];
              freqs.forEach((f, i) => {
                 const osc = this.ctx.createOscillator();
                 const g = this.ctx.createGain();
                 osc.type = 'sine';
                 osc.frequency.setValueAtTime(f, t);
                 osc.frequency.linearRampToValueAtTime(f + 10, t + 1);
                 g.gain.setValueAtTime(0.1, t);
                 g.gain.exponentialRampToValueAtTime(0.001, t + 1.5);
                 osc.connect(g); g.connect(this.ctx.destination);
                 osc.start(t); osc.stop(t + 1.5);
              });
          } catch(e) {}
        },

        startJetpack: function() {
           if (this.isMuted || !this.ctx || this.jetpackNode) return;
           try {
               if (!this.noiseBuffer) this.createNoiseBuffer();
               const source = this.ctx.createBufferSource();
               source.buffer = this.noiseBuffer;
               source.loop = true;
               const filter = this.ctx.createBiquadFilter();
               filter.type = 'lowpass';
               filter.frequency.value = 400;
               const gain = this.ctx.createGain();
               gain.gain.value = 0.1; 
               source.connect(filter); filter.connect(gain); gain.connect(this.ctx.destination);
               source.start();
               this.jetpackNode = source;
           } catch(e) {}
        },

        stopJetpack: function() {
           if (this.jetpackNode) {
               try { this.jetpackNode.stop(); this.jetpackNode.disconnect(); } catch(e) {}
               this.jetpackNode = null;
           }
        },

        gameOver: function() {
          // No sound for game over
        },

        buy: function() {
           if (this.isMuted || !this.ctx) return;
           this.playTone(600, 'square', 0.1, 0.05);
           setTimeout(() => this.playTone(800, 'square', 0.2, 0.05), 100);
        },
        
        missionComplete: function() {
           if (this.isMuted || !this.ctx) return;
           this.playTone(523, 'sine', 0.1, 0.1);
           setTimeout(() => this.playTone(659, 'sine', 0.1, 0.1), 100);
           setTimeout(() => this.playTone(783, 'sine', 0.4, 0.1), 200);
        },
        
        toggle: function() {
           if (this.isMuted || !this.ctx) return;
           this.playTone(1000, 'sine', 0.05, 0.05);
        },

        doorsClosing: function() {
            // Sound removed
        }
      };


      // --- GAME COMPONENT ---
      const GameCanvas = () => {
// --- LEADERBOARD STATE ---
        const [leaderboard, setLeaderboard] = useState([]);
        const [isUploading, setIsUploading] = useState(false);
        const [hasEnteredName, setHasEnteredName] = useState(false); 

        const submitScoreAndFetchLeaderboard = async (finalScore) => {
            setIsUploading(true);
            const nameToSave = playerName || 'Driver';
            
            // 1. Score hochladen (Tabelle hei√üt 'highscore')
            await supabase.from('highscore').insert({ player_name: nameToSave, score: finalScore });

            // 2. Bestenliste laden (Top 10)
            const { data } = await supabase
                .from('highscore')
                .select('player_name, score')
                .order('score', { ascending: false })
                .limit(10);
            
            if (data) setLeaderboard(data);
            setIsUploading(false);
        };

        const fetchLeaderboardOnly = async () => {
            const { data } = await supabase
                .from('highscore')
                .select('player_name, score')
                .order('score', { ascending: false })
                .limit(10);
            if (data) setLeaderboard(data);
        };
        // -------------------------
        const canvasRef = useRef(null);
        const [gameState, setGameState] = useState(GameState.SPLASH);
        const [score, setScore] = useState(0);
        const [shopTab, setShopTab] = useState('SKINS'); 
        
        // Transition State
        const [doorState, setDoorState] = useState('IDLE'); // IDLE, CLOSING, CLOSED, OPENING
        
        // Persistent State
        const [highScore, setHighScore] = useState(0);
        const [coins, setCoins] = useState(0);
        const [ownedSkins, setOwnedSkins] = useState([SkinType.NONE]);
        const [equippedSkin, setEquippedSkin] = useState(SkinType.NONE);
        const [inventory, setInventory] = useState({ 
            [ConsumableType.ROCKET]: 0, 
            [ConsumableType.REVIVE]: 0,
            [ConsumableType.DOUBLE_COINS]: 0,
            [ConsumableType.LUCKY_CHARM]: 0
        });
        const [isMuted, setIsMuted] = useState(false);
        const [language, setLanguage] = useState('EN'); // 'EN' or 'DE'
        const [coinAnim, setCoinAnim] = useState(false);
        const [playerName, setPlayerName] = useState('Driver');
        
        // Session Loadout State (Toggles on Start Screen)
        const [loadout, setLoadout] = useState({
            [ConsumableType.ROCKET]: false,
            [ConsumableType.REVIVE]: false,
            [ConsumableType.DOUBLE_COINS]: false,
            [ConsumableType.LUCKY_CHARM]: false
        });
        
        // Mission State
        const [missionStats, setMissionStats] = useState({
             totalScore: 0,
             totalCoins: 0,
             totalJumps: 0,
             totalPowerups: 0,
             totalGames: 0,
             tiers: { 
                 [MissionCategory.HEIGHT]: 0,
                 [MissionCategory.COINS]: 0,
                 [MissionCategory.JUMPS]: 0,
                 [MissionCategory.POWERUPS]: 0,
                 [MissionCategory.GAMES]: 0,
                 [MissionCategory.STOPS]: 0
             }
        });
        
        const [nameInput, setNameInput] = useState('');

        // Logic Refs
        const playerRef = useRef({
          x: CANVAS_WIDTH / 2 - PLAYER_WIDTH / 2,
          y: CANVAS_HEIGHT - 150,
          width: PLAYER_WIDTH,
          height: PLAYER_HEIGHT,
          vx: 0,
          vy: 0,
          rotation: 0,
          isJetpacking: false,
          jetpackTimer: 0,
          isMagnetActive: false,
          magnetTimer: 0,
        });

        const platformsRef = useRef([]);
        const particlesRef = useRef([]); 
        const floatingCoinsRef = useRef([]); 
        const scoreRef = useRef(0);
        const nextRoundelHeightRef = useRef(3000);
        
        const sessionStatsRef = useRef({
            coins: 0,
            jumps: 0,
            powerups: 0,
            reviveUsed: false,
            activeEffects: [],
            stops: 0
        });
        
        const missionStatsRef = useRef({});
        const keysRef = useRef({});
        const animationFrameRef = useRef(0);
        const shakeRef = useRef(0);
        const introTimerRef = useRef(0);
        const roundelsRef = useRef([]);
        
        const t = (key) => {
            const lang = (TRANSLATIONS[language]) ? language : 'EN';
            return TRANSLATIONS[lang][key] || key;
        };
        
        // Load Data
        useEffect(() => {
          const savedData = localStorage.getItem('tubeJumpData_v8'); 
          
          let loadedCoins = 0;
          let loadedHighScore = 0;
          let loadedSkins = [SkinType.NONE];
          let loadedEquipped = SkinType.NONE;
          let loadedMute = false;
          let loadedLang = 'EN';
          let loadedName = 'Driver';
          let loadedInventory = { 
              [ConsumableType.ROCKET]: 0, 
              [ConsumableType.REVIVE]: 0,
              [ConsumableType.DOUBLE_COINS]: 0,
              [ConsumableType.LUCKY_CHARM]: 0
          };
          let loadedMissionStats = {
             totalScore: 0,
             totalCoins: 0,
             totalJumps: 0,
             totalPowerups: 0,
             totalGames: 0,
             tiers: {
                 [MissionCategory.HEIGHT]: 0,
                 [MissionCategory.COINS]: 0,
                 [MissionCategory.JUMPS]: 0,
                 [MissionCategory.POWERUPS]: 0,
                 [MissionCategory.GAMES]: 0,
                 [MissionCategory.STOPS]: 0
             }
          };

          if (savedData) {
            try {
                const parsed = JSON.parse(savedData);
                loadedHighScore = parsed.highScore || 0;
                loadedCoins = parsed.coins || 0;
                loadedSkins = parsed.ownedSkins || [SkinType.NONE];
                loadedEquipped = parsed.equippedSkin || SkinType.NONE;
                if (parsed.isMuted !== undefined) loadedMute = parsed.isMuted;
                if (parsed.language !== undefined) loadedLang = parsed.language;
                if (parsed.playerName !== undefined) {
                    loadedName = parsed.playerName;
                    setHasEnteredName(true); 
                }
                if (parsed.inventory) loadedInventory = { ...loadedInventory, ...parsed.inventory };
                if (parsed.missionStats) {
                    loadedMissionStats = { ...loadedMissionStats, ...parsed.missionStats };
                    if (loadedMissionStats.totalGames === undefined) loadedMissionStats.totalGames = 0;
                }
                if (!loadedMissionStats.tiers) loadedMissionStats.tiers = {};
                Object.values(MissionCategory).forEach(cat => {
                     if (loadedMissionStats.tiers[cat] === undefined) loadedMissionStats.tiers[cat] = 0;
                });
            } catch(e) {
                console.warn("Save file corrupted, resetting", e);
            }
          }

          setHighScore(loadedHighScore);
          setCoins(loadedCoins);
          setOwnedSkins(loadedSkins);
          setEquippedSkin(loadedEquipped);
          setInventory(loadedInventory);
          setIsMuted(loadedMute);
          setLanguage(loadedLang);
          setPlayerName(loadedName);
          setMissionStats(loadedMissionStats);
          missionStatsRef.current = JSON.parse(JSON.stringify(loadedMissionStats));
          AudioSys.isMuted = loadedMute;
        }, []);

        useEffect(() => {
            if (gameState === GameState.START || gameState === GameState.RANKING) {
                fetchLeaderboardOnly();
            }
        }, [gameState]);

        useEffect(() => {
            if (isMuted) AudioSys.stopJetpack();
        }, [isMuted]);

        const triggerCoinAnim = useCallback(() => {
            setCoinAnim(true);
            setTimeout(() => setCoinAnim(false), 200);
        }, []);

        const saveData = (newCoins, newOwned, newEquipped, newHighScore, newMute, newMissionStats, newInventory, newLang, newName) => {
          const data = {
            highScore: newHighScore !== undefined ? newHighScore : highScore,
            coins: newCoins !== undefined ? newCoins : coins,
            ownedSkins: newOwned || ownedSkins,
            equippedSkin: newEquipped || equippedSkin,
            isMuted: newMute !== undefined ? newMute : isMuted,
            language: newLang !== undefined ? newLang : language,
            playerName: newName !== undefined ? newName : playerName,
            missionStats: newMissionStats || missionStats,
            inventory: newInventory || inventory
          };
          localStorage.setItem('tubeJumpData_v8', JSON.stringify(data));
        };

        const toggleMute = () => {
          const newVal = !isMuted;
          setIsMuted(newVal);
          AudioSys.isMuted = newVal;
          saveData(undefined, undefined, undefined, undefined, newVal, undefined, undefined, undefined, undefined);
          if (!newVal) AudioSys.init();
        };
        
        const setLanguageAndSave = (lang) => {
            setLanguage(lang);
            saveData(undefined, undefined, undefined, undefined, undefined, undefined, undefined, lang, undefined);
            AudioSys.toggle();
        };
        
        // --- FULLSCREEN LOGIC ---
        const toggleFullScreen = () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch((err) => {
                    console.warn(`Error attempting to enable fullscreen: ${err.message}`);
                });
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        };
        
        const submitName = () => {
            const finalName = nameInput.trim() || 'Driver';
            setPlayerName(finalName);
            setHasEnteredName(true); 
            saveData(undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, finalName);
            setGameState(GameState.START);
            AudioSys.playTone(400, 'sine', 0.1);
        };

        const toggleLoadoutItem = (type) => {
            if (inventory[type] > 0) {
                setLoadout(prev => ({ ...prev, [type]: !prev[type] }));
                AudioSys.toggle();
            }
        };
        
        const claimMissionTier = (category) => {
            const currentTierIdx = missionStats.tiers[category];
            const defs = MISSION_DEFINITIONS[category];
            
            if (!defs || currentTierIdx >= defs.length) return;
            
            const mission = defs[currentTierIdx];
            let currentVal = 0;
            if (category === MissionCategory.HEIGHT) currentVal = missionStats.totalScore;
            if (category === MissionCategory.COINS) currentVal = missionStats.totalCoins;
            if (category === MissionCategory.JUMPS) currentVal = missionStats.totalJumps;
            if (category === MissionCategory.POWERUPS) currentVal = missionStats.totalPowerups;
            if (category === MissionCategory.GAMES) currentVal = missionStats.totalGames;
            if (category === MissionCategory.STOPS) currentVal = (missionStats.tiers[MissionCategory.STOPS] * 0) + sessionStatsRef.current.stops; 

            if (currentVal >= mission.target) {
                 const newCoins = coins + mission.reward;
                 const newMissionStats = { 
                     ...missionStats, 
                     tiers: { ...missionStats.tiers, [category]: currentTierIdx + 1 } 
                 };
                 
                 setCoins(newCoins);
                 setMissionStats(newMissionStats);
                 missionStatsRef.current = newMissionStats;
                 saveData(newCoins, undefined, undefined, undefined, undefined, newMissionStats, undefined, undefined, undefined);
                 AudioSys.missionComplete();
            }
        };

        const startIntro = () => {
          AudioSys.init();
          setGameState(GameState.INTRO);
          introTimerRef.current = 0;
          AudioSys.playIntroSequence();
        };

        const createParticles = (x, y, color, count, speed = 1, life = 1.0) => {
          for (let i = 0; i < count; i++) {
            particlesRef.current.push({
              x,
              y,
              vx: (Math.random() - 0.5) * speed * 4,
              vy: (Math.random() - 0.5) * speed * 4,
              life: life + Math.random() * 0.5,
              maxLife: life,
              color: color,
              size: Math.random() * 4 + 2,
            });
          }
        };

        const generatePlatform = (y, lastType = PlatformType.STATIC) => {
          const x = Math.random() * (CANVAS_WIDTH - PLATFORM_WIDTH);
          const currentScore = scoreRef.current;
          const typeRoll = Math.random();
          
          let type = PlatformType.STATIC;
          let vx = 0;
          let conveyorSpeed = 0;

          const forceSafe = lastType === PlatformType.GHOST || lastType === PlatformType.BREAKABLE;

          if (!forceSafe) {
              if (currentScore > ZONE_LIMITS.STATION && typeRoll > 0.75) {
                type = PlatformType.GHOST;
              } else if (currentScore > ZONE_LIMITS.TUBE && typeRoll > 0.7) {
                if (Math.random() > 0.5) {
                    type = PlatformType.CONVEYOR;
                    conveyorSpeed = (Math.random() > 0.5 ? 1 : -1) * 2.5;
                } else {
                    type = PlatformType.MOVING;
                    vx = 2 + Math.random() * 2;
                    if (Math.random() > 0.5) vx *= -1;
                }
              } else if (currentScore > 500 && typeRoll > 0.8) {
                type = PlatformType.MOVING;
                vx = 2 + Math.random() * 2;
                if (Math.random() > 0.5) vx *= -1;
              } else if (currentScore > 1500 && typeRoll > 0.92) {
                type = PlatformType.BREAKABLE;
              }
          } else {
              if (currentScore > 1000 && Math.random() > 0.6) {
                  type = PlatformType.MOVING;
                  vx = 2 + Math.random() * 2;
                  if (Math.random() > 0.5) vx *= -1;
              }
          }

          let powerup = PowerupType.NONE;
          let hasCoin = false;

          const isLucky = sessionStatsRef.current.activeEffects.includes(ConsumableType.LUCKY_CHARM);
          const multiplier = isLucky ? 2.5 : 1.0;

          if (type !== PlatformType.BREAKABLE && type !== PlatformType.GHOST) {
            const r = Math.random();
            if (r < 0.02 * multiplier) powerup = PowerupType.JETPACK; 
            else if (r < 0.07 * multiplier) powerup = PowerupType.MAGNET; 
            else if (r < 0.15 * multiplier) powerup = PowerupType.SPRING;
            else if (Math.random() < 0.3) hasCoin = true;
          }

          return {
            id: Math.random(),
            x, y,
            width: PLATFORM_WIDTH,
            height: PLATFORM_HEIGHT,
            type,
            vx,
            conveyorSpeed,
            isBroken: false,
            powerup,
            hasCoin,
            coinOffset: Math.random() * Math.PI * 2,
            ghostOffset: Math.random() * 100, 
            ghostVisible: true
          };
        };
        
        const consumeReviveItem = () => {
            setInventory(prev => {
                const updated = { ...prev };
                if (updated[ConsumableType.REVIVE] > 0) {
                    updated[ConsumableType.REVIVE]--;
                }
                saveData(undefined, undefined, undefined, undefined, undefined, undefined, updated, undefined, undefined);
                return updated;
            });
        };

        const handleStartGame = () => {
            // NEU: Audio Context f√ºr Mobile aufwecken
            if (AudioSys.ctx && AudioSys.ctx.state === 'suspended') AudioSys.ctx.resume();

            setDoorState('CLOSING');
            // AudioSys.doorsClosing(); // Sound removed as requested
            setTimeout(() => {
                setDoorState('CLOSED');
                initGame();
                setTimeout(() => {
                    setDoorState('OPENING');
                    setTimeout(() => {
                        setDoorState('IDLE');
                    }, 700);
                }, 500);
            }, 700);
        };

        const initGame = useCallback(() => {
          AudioSys.init(); 
          
          const currentEffects = [];
          const newInv = { ...inventory };
          
          if (loadout[ConsumableType.ROCKET] && newInv[ConsumableType.ROCKET] > 0) {
              currentEffects.push(ConsumableType.ROCKET);
              newInv[ConsumableType.ROCKET]--;
          }
          if (loadout[ConsumableType.DOUBLE_COINS] && newInv[ConsumableType.DOUBLE_COINS] > 0) {
              currentEffects.push(ConsumableType.DOUBLE_COINS);
              newInv[ConsumableType.DOUBLE_COINS]--;
          }
          if (loadout[ConsumableType.LUCKY_CHARM] && newInv[ConsumableType.LUCKY_CHARM] > 0) {
              currentEffects.push(ConsumableType.LUCKY_CHARM);
              newInv[ConsumableType.LUCKY_CHARM]--;
          }
          if (loadout[ConsumableType.REVIVE] && newInv[ConsumableType.REVIVE] > 0) {
              currentEffects.push(ConsumableType.REVIVE);
          }
          
          setInventory(newInv);
          setLoadout({
            [ConsumableType.ROCKET]: false,
            [ConsumableType.REVIVE]: false,
            [ConsumableType.DOUBLE_COINS]: false,
            [ConsumableType.LUCKY_CHARM]: false
          });
          
          saveData(undefined, undefined, undefined, undefined, undefined, undefined, newInv, undefined, undefined);

          const rocketActive = currentEffects.includes(ConsumableType.ROCKET);

          // SAFE START: Place player lower and ensure center platform
          playerRef.current = {
            x: CANVAS_WIDTH / 2 - PLAYER_WIDTH / 2,
            y: CANVAS_HEIGHT - 200, // Lower position
            width: PLAYER_WIDTH,
            height: PLAYER_HEIGHT,
            vx: 0,
            vy: rocketActive ? JETPACK_SPEED : JUMP_FORCE,
            rotation: 0,
            isJetpacking: rocketActive,
            jetpackTimer: rocketActive ? 200 : 0, 
            isMagnetActive: false,
            magnetTimer: 0
          };

          scoreRef.current = 0;
          nextRoundelHeightRef.current = 3000;
          sessionStatsRef.current = { 
              coins: 0, 
              jumps: 0, 
              powerups: 0,
              reviveUsed: false,
              activeEffects: currentEffects,
              stops: 0
          };
          
          setScore(0);
          particlesRef.current = [];
          floatingCoinsRef.current = [];
          roundelsRef.current = [];
          shakeRef.current = 0;
          missionStatsRef.current = JSON.parse(JSON.stringify(missionStats));

          const initialPlatforms = [];
          let currentY = CANVAS_HEIGHT;
          
          // SAFE START: Center platform directly under player
          initialPlatforms.push({
            id: 0,
            x: CANVAS_WIDTH / 2 - PLATFORM_WIDTH / 2, 
            y: CANVAS_HEIGHT - 100,
            width: PLATFORM_WIDTH,
            height: PLATFORM_HEIGHT,
            type: PlatformType.STATIC,
            vx: 0,
            isBroken: false,
            powerup: PowerupType.NONE,
            hasCoin: false,
            coinOffset: 0,
            ghostVisible: true
          });

          let lastType = PlatformType.STATIC;
          while (currentY > 0) {
            currentY -= (Math.random() * (PLATFORM_GAP_MAX - 40) + 40);
            const newPlat = generatePlatform(currentY, lastType);
            initialPlatforms.push(newPlat);
            lastType = newPlat.type;
          }
          
          platformsRef.current = initialPlatforms;
          setGameState(GameState.PLAYING);
        }, [inventory, missionStats, loadout]);

        const collectCoin = () => {
            const double = sessionStatsRef.current.activeEffects.includes(ConsumableType.DOUBLE_COINS);
            const amount = double ? 2 : 1;
            sessionStatsRef.current.coins += amount;
            setCoins(prev => prev + amount);
            triggerCoinAnim();
            AudioSys.coin();
            if (double) AudioSys.coin(); 
        };

        const draw = (ctx, time) => {
          ctx.save();
          
          // INTRO
          if (gameState === GameState.INTRO) {
              const t = introTimerRef.current;
              const maxT = 400;
              ctx.fillStyle = '#0a0a0a'; ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
              ctx.fillStyle = '#333'; ctx.fillRect(0, CANVAS_HEIGHT - 150, CANVAS_WIDTH, 150);
              ctx.fillStyle = COLORS.YELLOW; ctx.fillRect(0, CANVAS_HEIGHT - 150, CANVAS_WIDTH, 8); 
              const trainWidth = 600; const trainHeight = 280; const targetX = CANVAS_WIDTH / 2 - trainWidth / 2;
              let trainX = -trainWidth; 
              if (t < 180) { const p = t / 180; const ease = 1 - Math.pow(1 - p, 3); trainX = -trainWidth + (targetX + trainWidth) * ease; } else { trainX = targetX; }
              let doorOpenGap = 0;
              if (t > 250) { const dp = Math.min(1, (t - 250) / 60); const easeD = dp < .5 ? 2 * dp * dp : -1 + (4 - 2 * dp) * dp; doorOpenGap = easeD * 80; }
              
              // Zoom Effect
              if (t > 320) { const zp = (t - 320) / 80; const scale = Math.pow(20, zp); const centerX = CANVAS_WIDTH / 2; const centerY = CANVAS_HEIGHT - 150 - trainHeight / 2 + 20; ctx.translate(centerX, centerY); ctx.scale(scale, scale); ctx.translate(-centerX, -centerY); }
              
              // Draw Station Sign above train (NEW: UNDERGROUND ROUNDEL) - VISIBLE FROM START
              if (t <= 320) {
                  const signY = 110; 
                  const cx = CANVAS_WIDTH / 2;
                  
                  // Red Circle
                  ctx.fillStyle = COLORS.RED;
                  ctx.beginPath(); ctx.arc(cx, signY, 50, 0, Math.PI * 2); ctx.fill();
                  
                  // White Inner
                  ctx.fillStyle = COLORS.WHITE;
                  ctx.beginPath(); ctx.arc(cx, signY, 35, 0, Math.PI * 2); ctx.fill();
                  
                  // Blue Bar
                  ctx.fillStyle = COLORS.BLUE;
                  ctx.fillRect(cx - 60, signY - 10, 120, 20);
                  
                  // Text
                  ctx.font = 'bold 14px "P22 Underground", sans-serif';
                  ctx.textAlign = 'center';
                  ctx.textBaseline = 'middle';
                  ctx.fillStyle = '#FFF';
                  ctx.fillText("UNDERGROUND", cx, signY);
              }

              ctx.fillStyle = COLORS.DTUP_WHITE; ctx.fillRect(trainX, CANVAS_HEIGHT - 150 - trainHeight, trainWidth, trainHeight);
              ctx.fillStyle = COLORS.DTUP_BLUE; ctx.fillRect(trainX, CANVAS_HEIGHT - 150 - 40, trainWidth, 40);
              ctx.fillStyle = '#000'; ctx.beginPath(); ctx.roundRect(trainX + 20, CANVAS_HEIGHT - 150 - 200, trainWidth - 40, 100, 10); ctx.fill();
              const doorW = 70; const doorH = 180; const doorY = CANVAS_HEIGHT - 150 - doorH; const doorCenterX = trainX + trainWidth / 2;
              ctx.fillStyle = COLORS.DARK; ctx.fillRect(doorCenterX - doorW, doorY, doorW * 2, doorH);
              const drawDoor = (xOffset) => { ctx.fillStyle = '#F0F0F0'; ctx.fillRect(doorCenterX + xOffset, doorY, doorW, doorH); ctx.fillStyle = '#2d3436'; ctx.fillRect(doorCenterX + xOffset + 10, doorY + 20, doorW - 20, 100); ctx.fillStyle = '#111'; ctx.fillRect(doorCenterX + xOffset - 2, doorY, 4, doorH); ctx.fillStyle = '#E32017'; ctx.beginPath(); ctx.arc(doorCenterX + xOffset + doorW/2, doorY + doorH/2 + 10, 6, 0, Math.PI*2); ctx.fill(); };
              drawDoor(-doorW - doorOpenGap); drawDoor(doorOpenGap);
              introTimerRef.current++;
              if (introTimerRef.current > maxT) setGameState(GameState.NAME_INPUT);
              ctx.restore();
              return;
          }

          if (shakeRef.current > 0) {
            const shakeX = (Math.random() - 0.5) * shakeRef.current;
            const shakeY = (Math.random() - 0.5) * shakeRef.current;
            ctx.translate(shakeX, shakeY);
            shakeRef.current *= 0.9; 
            if (shakeRef.current < 0.5) shakeRef.current = 0;
          }

          const s = scoreRef.current; const T_RANGE = 1500; 
          const parallaxY = s * 0.5; 

          const drawDeepTube = (alpha) => { 
            ctx.save(); ctx.globalAlpha = alpha; 
            ctx.fillStyle = COLORS.DARK; ctx.fillRect(-20, -20, CANVAS_WIDTH + 40, CANVAS_HEIGHT + 40); 
            // Parallax Pipes
            ctx.lineWidth = 4; ctx.strokeStyle = '#1a1a1a'; 
            for(let i=0; i<3; i++) { 
                const px = 50 + i*120;
                const pipeY = (parallaxY % 300) - 300; 
                ctx.beginPath(); ctx.moveTo(px, -50); ctx.lineTo(px, CANVAS_HEIGHT + 50); ctx.stroke();
                ctx.lineWidth = 8; ctx.strokeStyle = '#222';
                for(let j=0; j<CANVAS_HEIGHT+300; j+=100) {
                     const tieY = pipeY + j;
                     if(tieY > -50 && tieY < CANVAS_HEIGHT+50) { ctx.beginPath(); ctx.moveTo(px-5, tieY); ctx.lineTo(px+5, tieY); ctx.stroke(); }
                }
                ctx.lineWidth = 4; ctx.strokeStyle = '#1a1a1a';
            }
            ctx.restore(); 
          };

          const drawStation = (alpha) => { 
            ctx.save(); ctx.globalAlpha = alpha; 
            ctx.fillStyle = COLORS.STATION_BG; ctx.fillRect(-20, -20, CANVAS_WIDTH + 40, CANVAS_HEIGHT + 40); 
            ctx.strokeStyle = '#d4d4d4'; ctx.lineWidth = 1; ctx.beginPath(); 
            for (let i = 0; i < CANVAS_HEIGHT; i += 40) { const visualY = (i + (s % 40)) % CANVAS_HEIGHT; ctx.moveTo(0, visualY); ctx.lineTo(CANVAS_WIDTH, visualY); } 
            for (let i = 0; i < CANVAS_WIDTH; i += 60) { ctx.moveTo(i, 0); ctx.lineTo(i, CANVAS_HEIGHT); } ctx.stroke(); 
            const pillarOffset = (parallaxY % 600) - 600;
            ctx.fillStyle = '#ccc';
            for(let i=0; i<CANVAS_HEIGHT+600; i+=300) {
                const py = pillarOffset + i;
                if(py > -100 && py < CANVAS_HEIGHT+100) { ctx.fillRect(0, py, 40, 200); ctx.fillRect(CANVAS_WIDTH-40, py, 40, 200); }
            }
            ctx.restore(); 
          };

          const drawCity = (alpha) => { 
            ctx.save(); ctx.globalAlpha = alpha; 
            // Day Sky Gradient
            const grad = ctx.createLinearGradient(0, 0, 0, CANVAS_HEIGHT);
            grad.addColorStop(0, '#60A5FA'); // Light Blue 400
            grad.addColorStop(1, '#DBEAFE'); // Light Blue 100
            ctx.fillStyle = grad;
            ctx.fillRect(-20, -20, CANVAS_WIDTH + 40, CANVAS_HEIGHT + 40);

            // Sun
            ctx.fillStyle = '#FCD34D'; // Yellow 300
            ctx.beginPath(); ctx.arc(320, 80, 40, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.beginPath(); ctx.arc(320, 80, 50, 0, Math.PI*2); ctx.fill();

            // REMOVED: Big Ben / Skyline Parallax Loops to reduce visual bugginess/clutter
            
            // Clouds (Keep these)
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            const cloudOff = (s * 0.05) % CANVAS_HEIGHT;
            for(let c=0; c<5; c++) {
                const cy = (cloudOff + c*200) % CANVAS_HEIGHT;
                const cx = (c * 100) % CANVAS_WIDTH;
                ctx.beginPath(); ctx.arc(cx, cy, 30, 0, Math.PI*2); ctx.arc(cx+20, cy-10, 40, 0, Math.PI*2); ctx.arc(cx+50, cy, 30, 0, Math.PI*2); ctx.fill();
            }

            ctx.restore(); 
          };

          const drawSpace = (alpha) => {
             ctx.save(); ctx.globalAlpha = alpha;
             ctx.fillStyle = COLORS.SPACE_BG; ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
             ctx.fillStyle = '#FFF';
             const starOff = s * 0.05;
             for(let i=0; i<80; i++) {
                 const sx = (i * 47) % CANVAS_WIDTH;
                 const sy = ((i * 19) + starOff) % CANVAS_HEIGHT;
                 const size = (i % 3) + 1;
                 ctx.globalAlpha = alpha * (Math.sin(i + time/300) * 0.4 + 0.6);
                 ctx.fillRect(sx, sy, size/2, size/2);
             }
             const planetY = (parallaxY * 0.1);
             ctx.globalAlpha = alpha * 0.8;
             
             const p1y = (planetY + 100) % (CANVAS_HEIGHT + 400) - 200;
             ctx.fillStyle = '#4a1e75';
             ctx.beginPath(); ctx.arc(80, p1y, 60, 0, Math.PI*2); ctx.fill();
             ctx.strokeStyle = '#7a3e95'; ctx.lineWidth = 8; ctx.beginPath(); ctx.ellipse(80, p1y, 90, 20, -0.2, 0, Math.PI*2); ctx.stroke();

             const p2y = (planetY + 400) % (CANVAS_HEIGHT + 400) - 200;
             ctx.fillStyle = '#882222';
             ctx.beginPath(); ctx.arc(300, p2y, 40, 0, Math.PI*2); ctx.fill();
             ctx.fillStyle = '#661111'; ctx.beginPath(); ctx.arc(290, p2y-10, 8, 0, Math.PI*2); ctx.fill();
             ctx.beginPath(); ctx.arc(315, p2y+15, 12, 0, Math.PI*2); ctx.fill();

             ctx.restore();
          };

          if (s < ZONE_LIMITS.TUBE - T_RANGE) drawDeepTube(1); 
          else if (s < ZONE_LIMITS.TUBE) { drawDeepTube(1); drawStation((s - (ZONE_LIMITS.TUBE - T_RANGE)) / T_RANGE); } 
          else if (s < ZONE_LIMITS.STATION - T_RANGE) drawStation(1); 
          else if (s < ZONE_LIMITS.STATION) { drawStation(1); drawCity((s - (ZONE_LIMITS.STATION - T_RANGE)) / T_RANGE); } 
          else if (s < ZONE_LIMITS.CITY - T_RANGE) drawCity(1);
          else if (s < ZONE_LIMITS.CITY) { drawCity(1); drawSpace((s - (ZONE_LIMITS.CITY - T_RANGE)) / T_RANGE); }
          else drawSpace(1);

          // Background Roundels (Fixed to background layer)
          roundelsRef.current.forEach((r, i) => {
              if (!r.active) return;
              
              ctx.save();
              ctx.translate(CANVAS_WIDTH/2, r.y);
              ctx.scale(0.5, 0.5); // Smaller scale
              
              // Draw Roundel
              ctx.beginPath(); ctx.arc(0, 0, 60, 0, Math.PI*2); ctx.fillStyle = '#E32017'; ctx.fill();
              ctx.beginPath(); ctx.arc(0, 0, 40, 0, Math.PI*2); ctx.fillStyle = '#F0F0F0'; ctx.fill();
              ctx.fillStyle = '#003688'; ctx.fillRect(-80, -12, 160, 24);
              ctx.fillStyle = 'white'; ctx.font = 'bold 16px "P22 Underground", sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
              ctx.fillText(r.name.toUpperCase(), 0, 0);
              ctx.restore();

              if (r.y > CANVAS_HEIGHT + 100) {
                  roundelsRef.current.splice(i, 1);
              }
          });


          platformsRef.current.forEach(p => {
            if (p.isBroken) return; 
            if (p.type === PlatformType.GHOST) { if (!p.ghostVisible) { ctx.strokeStyle = '#5a3a2a'; ctx.lineWidth = 1; ctx.strokeRect(p.x, p.y, p.width, p.height); return; } ctx.globalAlpha = 0.7; }
            if (p.type === PlatformType.STATIC) ctx.fillStyle = COLORS.GREY; else if (p.type === PlatformType.MOVING) ctx.fillStyle = COLORS.GREEN; else if (p.type === PlatformType.BREAKABLE) ctx.fillStyle = COLORS.BROWN; else if (p.type === PlatformType.GHOST) ctx.fillStyle = COLORS.GHOST; else if (p.type === PlatformType.CONVEYOR) ctx.fillStyle = COLORS.ESCALATOR;

            ctx.fillRect(p.x, p.y, p.width, p.height);
            if (p.type === PlatformType.CONVEYOR) { ctx.fillStyle = COLORS.YELLOW; const offset = (time / 10) % 20; ctx.beginPath(); for(let i = -20; i < p.width; i+=20) { let startX = i + (p.conveyorSpeed > 0 ? offset : -offset); if (p.conveyorSpeed > 0 && startX > p.width) startX -= p.width + 20; if (p.conveyorSpeed < 0 && startX < -20) startX += p.width + 20; ctx.moveTo(p.x + startX, p.y); ctx.lineTo(p.x + startX + 10, p.y); ctx.lineTo(p.x + startX, p.y + p.height); ctx.lineTo(p.x + startX - 10, p.y + p.height); } ctx.save(); ctx.clip(new Path2D(`M${p.x},${p.y} h${p.width} v${p.height} h-${p.width} z`)); ctx.fill(); ctx.restore(); } else if (p.type === PlatformType.GHOST) { ctx.fillStyle = 'rgba(0,0,0,0.2)'; ctx.fillRect(p.x, p.y + 4, p.width, 2); ctx.fillRect(p.x, p.y + 10, p.width, 2); } else { ctx.fillStyle = 'rgba(0,0,0,0.2)'; ctx.fillRect(p.x, p.y + p.height - 6, p.width, 6); ctx.fillStyle = 'rgba(255,255,255,0.1)'; ctx.fillRect(p.x, p.y, p.width, 2); ctx.fillStyle = COLORS.YELLOW; ctx.fillRect(p.x + 2, p.y + 2, p.width - 4, 3); }
            ctx.globalAlpha = 1; 

            if (p.hasCoin) { const bobY = Math.sin(time / 200 + p.coinOffset) * 5; const cX = p.x + p.width / 2; const cY = p.y - 15 + bobY; ctx.fillStyle = COLORS.GOLD; ctx.beginPath(); ctx.arc(cX, cY, 8, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = '#FFF59D'; ctx.beginPath(); ctx.arc(cX - 2, cY - 2, 3, 0, Math.PI * 2); ctx.fill(); ctx.strokeStyle = '#B7950B'; ctx.lineWidth = 1; ctx.beginPath(); ctx.arc(cX, cY, 8, 0, Math.PI * 2); ctx.stroke(); }
            if (p.powerup === PowerupType.SPRING) { ctx.fillStyle = '#555'; ctx.fillRect(p.x + p.width/2 - 8, p.y - 3, 16, 3); ctx.beginPath(); ctx.strokeStyle = '#999'; ctx.lineWidth = 2; ctx.lineJoin = 'round'; ctx.lineCap = 'round'; const sx = p.x + p.width/2; const sy = p.y - 3; ctx.moveTo(sx - 7, sy); ctx.lineTo(sx + 7, sy - 4); ctx.lineTo(sx - 7, sy - 8); ctx.lineTo(sx + 7, sy - 12); ctx.lineTo(sx, sy - 16); ctx.stroke(); ctx.fillStyle = COLORS.RED; ctx.fillRect(p.x + p.width/2 - 8, p.y - 18, 16, 4); } else if (p.powerup === PowerupType.JETPACK) { const jX = p.x + p.width/2; const jY = p.y - 22; ctx.fillStyle = '#C0C0C0'; ctx.beginPath(); ctx.roundRect(jX - 9, jY, 7, 18, 3); ctx.roundRect(jX + 2, jY, 7, 18, 3); ctx.fill(); ctx.fillStyle = COLORS.PURPLE; ctx.fillRect(jX - 10, jY + 5, 20, 5); ctx.fillStyle = '#444'; ctx.beginPath(); ctx.moveTo(jX - 8, jY + 18); ctx.lineTo(jX - 3, jY + 18); ctx.lineTo(jX - 5.5, jY + 22); ctx.moveTo(jX + 3, jY + 18); ctx.lineTo(jX + 8, jY + 18); ctx.lineTo(jX + 5.5, jY + 22); ctx.fill(); } else if (p.powerup === PowerupType.MAGNET) { const mX = p.x + p.width/2; const mY = p.y - 20; ctx.fillStyle = COLORS.MAGNET; ctx.beginPath(); ctx.arc(mX, mY, 12, Math.PI, 0); ctx.lineTo(mX + 12, mY + 10); ctx.lineTo(mX + 4, mY + 10); ctx.lineTo(mX + 4, mY); ctx.arc(mX, mY, 4, 0, Math.PI, true); ctx.lineTo(mX - 4, mY + 10); ctx.lineTo(mX - 12, mY + 10); ctx.closePath(); ctx.fill(); ctx.fillStyle = '#C0C0C0'; ctx.fillRect(mX - 12, mY + 6, 8, 4); ctx.fillRect(mX + 4, mY + 6, 8, 4); }
          });

          floatingCoinsRef.current.forEach(c => { ctx.fillStyle = COLORS.GOLD; ctx.beginPath(); ctx.arc(c.x, c.y, 8, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = '#FFF59D'; ctx.beginPath(); ctx.arc(c.x - 2, c.y - 2, 3, 0, Math.PI * 2); ctx.fill(); ctx.strokeStyle = '#B7950B'; ctx.lineWidth = 1; ctx.beginPath(); ctx.arc(c.x, c.y, 8, 0, Math.PI * 2); ctx.stroke(); });
          particlesRef.current.forEach(p => { ctx.fillStyle = p.color; ctx.globalAlpha = Math.max(0, p.life); ctx.beginPath(); ctx.rect(p.x, p.y, p.size, p.size); ctx.fill(); });
          ctx.globalAlpha = 1.0;

          const { x, y, width, height, rotation, isJetpacking, isMagnetActive } = playerRef.current;
          ctx.save(); ctx.translate(x + width / 2, y + height / 2); ctx.rotate(rotation);

          if (isJetpacking) { ctx.fillStyle = COLORS.ORANGE; ctx.beginPath(); const flicker = Math.random() * 15; ctx.moveTo(-10, height/2); ctx.lineTo(0, height/2 + 30 + flicker); ctx.lineTo(10, height/2); ctx.fill(); ctx.fillStyle = '#C0C0C0'; ctx.fillRect(-width/2 - 6, -10, 6, 25); ctx.fillRect(width/2, -10, 6, 25); ctx.fillStyle = COLORS.PURPLE; ctx.fillRect(-width/2 - 6, -5, 6, 5); ctx.fillRect(width/2, -5, 6, 5); }
          if (isMagnetActive) { ctx.save(); ctx.strokeStyle = 'rgba(200, 200, 255, 0.5)'; ctx.lineWidth = 2; const pulse = Math.sin(time / 100) * 5; ctx.beginPath(); ctx.arc(0, 0, width + 10 + pulse, 0, Math.PI * 2); ctx.stroke(); ctx.restore(); }
          const lightGrad = ctx.createLinearGradient(0, -height/2, 0, -height/2 - 120); lightGrad.addColorStop(0, 'rgba(255, 255, 200, 0.2)'); lightGrad.addColorStop(1, 'rgba(255, 255, 200, 0)'); ctx.fillStyle = lightGrad; ctx.beginPath(); ctx.moveTo(-10, -height/2); ctx.lineTo(-25, -height/2 - 120); ctx.lineTo(25, -height/2 - 120); ctx.lineTo(10, -height/2); ctx.fill();
          ctx.fillStyle = COLORS.RED; ctx.beginPath(); ctx.roundRect(-width/2, -height/2, width, height, 8); ctx.fill(); ctx.fillStyle = COLORS.BLUE; ctx.beginPath(); ctx.roundRect(-width/2, height/2 - 12, width, 12, [0, 0, 8, 8]); ctx.fill(); ctx.fillStyle = COLORS.WHITE; const windowSize = 12; ctx.fillRect(-width/2 + 5, -height/2 + 8, windowSize, windowSize); ctx.fillRect(width/2 - 5 - windowSize, -height/2 + 8, windowSize, windowSize); ctx.beginPath(); ctx.fillStyle = COLORS.WHITE; ctx.arc(0, 6, 9, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = COLORS.BLUE; ctx.fillRect(-11, 3, 22, 6);
          if (equippedSkin === SkinType.HARDHAT) { ctx.fillStyle = '#FBBF24'; ctx.beginPath(); ctx.arc(0, -height/2, width/2 + 2, Math.PI, 0); ctx.fill(); ctx.fillRect(-width/2 - 4, -height/2, width + 8, 6); } else if (equippedSkin === SkinType.TOPHAT) { ctx.fillStyle = '#111'; ctx.fillRect(-12, -height/2 - 25, 24, 25); ctx.fillRect(-width/2 - 2, -height/2 - 2, width + 4, 4); ctx.fillStyle = '#C0C0C0'; ctx.fillRect(-12, -height/2 - 8, 24, 4); } else if (equippedSkin === SkinType.VIKING) { ctx.fillStyle = '#9CA3AF'; ctx.beginPath(); ctx.arc(0, -height/2, width/2 + 2, Math.PI, 0); ctx.fill(); ctx.fillStyle = '#E5E7EB'; ctx.beginPath(); ctx.moveTo(-width/2, -height/2 - 5); ctx.quadraticCurveTo(-width/2 - 15, -height/2 - 25, -width/2 - 5, -height/2 - 30); ctx.lineTo(-width/2 - 2, -height/2 - 10); ctx.fill(); ctx.beginPath(); ctx.moveTo(width/2, -height/2 - 5); ctx.quadraticCurveTo(width/2 + 15, -height/2 - 25,(width/2 + 5), -height/2 - 30); ctx.lineTo(width/2 + 2, -height/2 - 10); ctx.fill(); } else if (equippedSkin === SkinType.ROYALGUARD) { ctx.fillStyle = '#111'; ctx.beginPath(); ctx.roundRect(-width/2 - 2, -height/2 - 28, width + 4, 30, 6); ctx.fill(); ctx.strokeStyle = '#FFD700'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(-width/2 + 2, -height/2); ctx.quadraticCurveTo(0, -height/2 + 12, width/2 - 2, -height/2); ctx.stroke(); } else if (equippedSkin === SkinType.CROWN) { ctx.fillStyle = '#FFD700'; ctx.beginPath(); ctx.moveTo(-15, -height/2); ctx.lineTo(-15, -height/2 - 15); ctx.lineTo(-8, -height/2 - 8); ctx.lineTo(0, -height/2 - 20); ctx.lineTo(8, -height/2 - 8); ctx.lineTo(15, -height/2 - 15); ctx.lineTo(15, -height/2); ctx.fill(); ctx.fillStyle = COLORS.RED; ctx.fillRect(-2, -height/2 - 8, 4, 4); }
          ctx.restore(); 
          
          const gradient = ctx.createRadialGradient(CANVAS_WIDTH/2, CANVAS_HEIGHT/2, CANVAS_WIDTH/3, CANVAS_WIDTH/2, CANVAS_HEIGHT/2, CANVAS_HEIGHT/1.2); gradient.addColorStop(0, 'rgba(0,0,0,0)'); gradient.addColorStop(1, 'rgba(0,0,0,0.6)'); ctx.fillStyle = gradient; ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
          ctx.restore(); 
        };

        // UPDATE GAME LOGIC
        const update = () => {
          if (gameState !== GameState.PLAYING) { AudioSys.stopJetpack(); return; }
          const player = playerRef.current;

          if (keysRef.current['ArrowLeft'] || keysRef.current['a']) { player.vx = -MOVEMENT_SPEED; player.rotation = -0.15; } else if (keysRef.current['ArrowRight'] || keysRef.current['d']) { player.vx = MOVEMENT_SPEED; player.rotation = 0.15; } else { player.vx = 0; player.rotation = 0; }
          player.x += player.vx; if (player.x + player.width < 0) player.x = CANVAS_WIDTH; else if (player.x > CANVAS_WIDTH) player.x = -player.width;

          platformsRef.current.forEach(p => { if (p.type === PlatformType.GHOST) { const cycle = (Date.now() / 10 + p.ghostOffset) % 200; p.ghostVisible = cycle < 100; } });

          if (player.isMagnetActive) {
              player.magnetTimer--; if (player.magnetTimer <= 0) player.isMagnetActive = false;
              platformsRef.current.forEach(p => { if (p.hasCoin) { const cX = p.x + p.width/2; const cY = p.y - 15; const dist = Math.sqrt(Math.pow((player.x + player.width/2) - cX, 2) + Math.pow((player.y + player.height/2) - cY, 2)); if (dist < 300) { p.hasCoin = false; floatingCoinsRef.current.push({ x: cX, y: cY, vx: 0, vy: 0 }); } } });
          }

          const pCenterX = player.x + player.width/2; const pCenterY = player.y + player.height/2;
          for (let i = floatingCoinsRef.current.length - 1; i >= 0; i--) {
              const c = floatingCoinsRef.current[i];
              const dx = pCenterX - c.x; const dy = pCenterY - c.y;
              c.x += dx * 0.1; c.y += dy * 0.1;
              if (Math.abs(dx) < 20 && Math.abs(dy) < 20) { collectCoin(); createParticles(c.x, c.y, COLORS.GOLD, 6, 2, 0.6); floatingCoinsRef.current.splice(i, 1); }
          }

          if (player.isJetpacking) { AudioSys.startJetpack(); player.vy = JETPACK_SPEED; player.jetpackTimer--; if (Math.random() > 0.3) createParticles(player.x + player.width/2, player.y + player.height, COLORS.ORANGE, 2, 2, 0.4); if (player.jetpackTimer <= 0) { player.isJetpacking = false; AudioSys.stopJetpack(); player.vy = JUMP_FORCE; } } else { AudioSys.stopJetpack(); player.vy += GRAVITY; if (player.vy > MAX_FALL_SPEED) player.vy = MAX_FALL_SPEED; }
          player.y += player.vy;

          const pRect = { left: player.x, right: player.x + player.width, top: player.y, bottom: player.y + player.height };
          platformsRef.current.forEach(p => {
             if (p.hasCoin) { const coinX = p.x + p.width/2; const coinY = p.y - 15; const dx = pCenterX - coinX; const dy = pCenterY - coinY; if (Math.sqrt(dx*dx + dy*dy) < 35) { p.hasCoin = false; collectCoin(); createParticles(coinX, coinY, COLORS.GOLD, 6, 2, 0.6); } }
             if (p.powerup === PowerupType.JETPACK) { const jX = p.x + p.width/2 - 10; const jY = p.y - 25; if (pRect.right > jX && pRect.left < jX + 20 && pRect.bottom > jY && pRect.top < jY + 25) { player.isJetpacking = true; player.jetpackTimer = 150; p.powerup = PowerupType.NONE; shakeRef.current = 5; sessionStatsRef.current.powerups++; } } 
             else if (p.powerup === PowerupType.MAGNET) { const mX = p.x + p.width/2 - 12; const mY = p.y - 20; if (pRect.right > mX && pRect.left < mX + 24 && pRect.bottom > mY && pRect.top < mY + 20) { player.isMagnetActive = true; player.magnetTimer = 600; p.powerup = PowerupType.NONE; AudioSys.magnet(); createParticles(mX+12, mY+10, '#50E3C2', 10, 3); sessionStatsRef.current.powerups++; } }
          });

          if (player.vy > 0 && !player.isJetpacking) {
            platformsRef.current.forEach(p => {
              if (p.type === PlatformType.GHOST && !p.ghostVisible) return;
              if (!p.isBroken && player.x + player.width * 0.8 > p.x && player.x + player.width * 0.2 < p.x + p.width && player.y + player.height > p.y && player.y + player.height < p.y + p.height + player.vy) {
                if (p.type === PlatformType.CONVEYOR) player.x += p.conveyorSpeed;
                if (p.type === PlatformType.BREAKABLE) { p.isBroken = true; player.vy = JUMP_FORCE * 0.3; shakeRef.current = 5; createParticles(p.x + p.width/2, p.y, COLORS.BROWN, 12, 3); AudioSys.crash(); } else { sessionStatsRef.current.jumps += 1; sessionStatsRef.current.stops += 1; if (p.powerup === PowerupType.SPRING) { player.vy = SPRING_FORCE; shakeRef.current = 3; createParticles(player.x + player.width/2, p.y, COLORS.GREEN, 8, 4); AudioSys.spring(); sessionStatsRef.current.powerups++; } else { player.vy = JUMP_FORCE; createParticles(player.x + player.width/2, player.y + player.height, '#DDD', 4, 1, 0.5); AudioSys.jump(); } }
              }
            });
          }

          platformsRef.current.forEach(p => { if (p.type === PlatformType.MOVING) { p.x += p.vx; if (p.x < 0 || p.x + p.width > CANVAS_WIDTH) p.vx *= -1; } });
          particlesRef.current.forEach(p => { p.x += p.vx; p.y += p.vy; p.life -= 0.02; p.vy += 0.1; }); particlesRef.current = particlesRef.current.filter(p => p.life > 0);

          if (player.y < CANVAS_HEIGHT / 2) {
            const diff = (CANVAS_HEIGHT / 2) - player.y; player.y = CANVAS_HEIGHT / 2; platformsRef.current.forEach(p => p.y += diff); floatingCoinsRef.current.forEach(c => c.y += diff); particlesRef.current.forEach(p => p.y += diff); scoreRef.current += Math.floor(diff); setScore(scoreRef.current);
            
            // Scroll Roundels (Station Signs)
            roundelsRef.current.forEach(r => r.y += diff);
            
            // Spawn Roundels logic
            const ROUNDEL_SPACING = 3000;
            if (scoreRef.current >= nextRoundelHeightRef.current) {
                 const stations = ["Piccadilly Circus", "Green Park", "Covent Garden", "Leicester Square", "Holborn", "Russell Square", "King's Cross", "Caledonian Road", "Holloway Road", "Arsenal", "Finsbury Park"];
                 const idx = Math.floor(nextRoundelHeightRef.current / ROUNDEL_SPACING) % stations.length;
                 roundelsRef.current.push({ y: -50, name: stations[idx], active: true }); // Spawn slightly above screen
                 nextRoundelHeightRef.current += ROUNDEL_SPACING;
            }

            platformsRef.current = platformsRef.current.filter(p => p.y < CANVAS_HEIGHT);
            const highestPlatform = platformsRef.current.reduce((prev, curr) => prev.y < curr.y ? prev : curr, {y: 9999, type: PlatformType.STATIC});
            if (highestPlatform.y > PLATFORM_GAP_MIN) { platformsRef.current.push(generatePlatform(highestPlatform.y - (Math.random() * (PLATFORM_GAP_MAX - 40) + 40), highestPlatform.type)); }
          }

          if (player.y > CANVAS_HEIGHT) {
            if (sessionStatsRef.current.activeEffects.includes(ConsumableType.REVIVE) && !sessionStatsRef.current.reviveUsed) {
                sessionStatsRef.current.reviveUsed = true;
                consumeReviveItem(); 
                player.vy = JUMP_FORCE * 1.5; player.y = CANVAS_HEIGHT - 50; shakeRef.current = 15; AudioSys.revive(); 
                createParticles(player.x + player.width/2, player.y, '#FF0055', 20, 5); 
                return;
            }
            shakeRef.current = 20; 
            const isNewHigh = scoreRef.current > highScore; if (isNewHigh) setHighScore(scoreRef.current);
            
            const newMissionStats = { ...missionStatsRef.current };
            if (scoreRef.current > newMissionStats.totalScore) newMissionStats.totalScore = scoreRef.current;
            newMissionStats.totalCoins += sessionStatsRef.current.coins;
            newMissionStats.totalJumps += sessionStatsRef.current.jumps;
            newMissionStats.totalPowerups += sessionStatsRef.current.powerups;
            newMissionStats.totalGames += 1;
            
            setMissionStats(newMissionStats);
            saveData(coins, null, null, isNewHigh ? scoreRef.current : highScore, undefined, newMissionStats, inventory, undefined, undefined);
           
            submitScoreAndFetchLeaderboard(scoreRef.current); 
            // -------------------------------------

            setGameState(GameState.TERMINATED_ANIM);
            setGameState(GameState.TERMINATED_ANIM);
            AudioSys.gameOver();
            setTimeout(() => {
                setGameState(GameState.GAME_OVER);
            }, 1200);
          }
        };

        const loop = (time) => {
          const canvas = canvasRef.current;
          if (!canvas) return; const ctx = canvas.getContext('2d'); if (!ctx) return;
          update(); draw(ctx, time);
          if (gameState === GameState.PLAYING || gameState === GameState.INTRO || gameState === GameState.TERMINATED_ANIM) { animationFrameRef.current = requestAnimationFrame(loop); } 
          else if ([GameState.SPLASH, GameState.START, GameState.GAME_OVER, GameState.SHOP, GameState.MISSIONS, GameState.SETTINGS, GameState.NAME_INPUT, GameState.RANKING].includes(gameState)) { draw(ctx, time); if (gameState === GameState.SHOP || gameState === GameState.SPLASH || gameState === GameState.START || gameState === GameState.MISSIONS || gameState === GameState.SETTINGS || gameState === GameState.NAME_INPUT || gameState === GameState.RANKING) { animationFrameRef.current = requestAnimationFrame(loop); } }
        };

        useEffect(() => {
          const handleKeyDown = (e) => { keysRef.current[e.key] = true; if ((gameState === GameState.GAME_OVER || gameState === GameState.START) && e.key === 'Enter') handleStartGame(); if (gameState === GameState.SPLASH && e.key === 'Enter') startIntro(); if (gameState === GameState.NAME_INPUT && e.key === 'Enter') submitName(); };
          const handleKeyUp = (e) => keysRef.current[e.key] = false;
          window.addEventListener('keydown', handleKeyDown); window.removeEventListener('keyup', handleKeyUp);
          return () => { window.removeEventListener('keydown', handleKeyDown); window.removeEventListener('keyup', handleKeyUp); };
        }, [gameState, handleStartGame, nameInput]);

        useEffect(() => { animationFrameRef.current = requestAnimationFrame(loop); return () => cancelAnimationFrame(animationFrameRef.current); }, [gameState]);
        const handleTouchStart = (direction) => { if (direction === 'left') keysRef.current['ArrowLeft'] = true; else keysRef.current['ArrowRight'] = true; }; const handleTouchEnd = () => { keysRef.current['ArrowLeft'] = false; keysRef.current['ArrowRight'] = false; };

        const buySkin = (item) => { if (coins >= item.price && !ownedSkins.includes(item.id)) { const newCoins = coins - item.price; const newOwned = [...ownedSkins, item.id]; setCoins(newCoins); setOwnedSkins(newOwned); setEquippedSkin(item.id); saveData(newCoins, newOwned, item.id, undefined, undefined, undefined, undefined, undefined, undefined); AudioSys.buy(); } };
        const buyConsumable = (item) => { if (coins >= item.price) { const newCoins = coins - item.price; const newInv = { ...inventory }; newInv[item.id] = (newInv[item.id] || 0) + 1; setCoins(newCoins); setInventory(newInv); saveData(newCoins, undefined, undefined, undefined, undefined, undefined, newInv, undefined, undefined); AudioSys.buy(); } };
        const equipSkin = (skinId) => { if (ownedSkins.includes(skinId)) { setEquippedSkin(skinId); saveData(undefined, undefined, skinId, undefined, undefined, undefined, undefined, undefined, undefined); AudioSys.playTone(400, 'sine', 0.1); } };
        const showHud = gameState === GameState.PLAYING || gameState === GameState.GAME_OVER || gameState === GameState.SHOP || gameState === GameState.MISSIONS || gameState === GameState.RANKING;

        return (
          <div className="relative w-full max-w-md mx-auto bg-neutral-900 shadow-2xl rounded-xl overflow-hidden border-4 border-gray-800 select-none">
            <div className="absolute top-4 left-4 z-50 space-y-1">
               {showHud && (
                 <>
                   <div className="bg-white/90 px-3 py-1 rounded-md shadow-md border-l-4 border-[#E32017]">
                    <p className="text-sm font-bold text-gray-800">{t('HEIGHT')}: {score}</p>
                    <p className="text-xs text-gray-500">{t('BEST')}: {highScore}</p>
                  </div>
                  <div className={`bg-white/90 px-3 py-1 rounded-md shadow-md border-l-4 border-[#FFD700] flex items-center gap-2 transition-transform duration-100 ${coinAnim ? 'scale-110 brightness-110' : 'scale-100'}`}>
                    <div className="w-3 h-3 rounded-full bg-[#FFD700] border border-[#B7950B]"></div>
                    <p className="text-sm font-bold text-gray-800">{coins}</p>
                  </div>
                 </>
               )}
              {/* CHANGED: Mute button removed from here, replaced with Fullscreen Button */}
              <button onClick={toggleFullScreen} className="bg-white/90 p-1 rounded-md shadow-md hover:bg-gray-200 mt-1 w-8 h-8 flex items-center justify-center">
                 ‚õ∂
              </button>
            </div>
            
            <div className="absolute top-4 right-4 z-10 flex flex-col items-end pointer-events-none select-none">
              <div className="bg-white/90 px-2 py-1 rounded-md shadow-md mb-1">
                  <span className="font-sans font-black text-[#009999] text-lg leading-none tracking-tight">SIEMENS</span>
              </div>
              {hasEnteredName && (
                  <div className="bg-black text-white font-mono text-xs px-1 py-0.5 border border-gray-500 shadow-sm uppercase tracking-wider animate-fade-in">
                      {playerName}
                  </div>
              )}
            </div>

            <canvas ref={canvasRef} width={CANVAS_WIDTH} height={CANVAS_HEIGHT} className="block w-full h-auto bg-[#111]" style={{ imageRendering: 'pixelated' }}/>
            
            {/* Door Overlay Animation */}
            <div className={`absolute inset-0 z-50 pointer-events-none flex ${doorState === 'IDLE' ? 'hidden' : ''}`}>
                <div 
                    className="w-1/2 h-full bg-[#222] border-r-4 border-black relative transition-transform duration-700 ease-in-out flex items-center justify-end"
                    style={{ transform: (doorState === 'OPENING') ? 'translateX(-100%)' : (doorState === 'CLOSING' || doorState === 'CLOSED' ? 'translateX(0)' : 'translateX(-100%)') }}
                >
                     <div className="w-16 h-32 border-4 border-[#111] bg-[#444] mr-4 rounded"></div>
                </div>
                <div 
                    className="w-1/2 h-full bg-[#222] border-l-4 border-black relative transition-transform duration-700 ease-in-out flex items-center justify-start"
                    style={{ transform: (doorState === 'OPENING') ? 'translateX(100%)' : (doorState === 'CLOSING' || doorState === 'CLOSED' ? 'translateX(0)' : 'translateX(100%)') }}
                >
                    <div className="w-16 h-32 border-4 border-[#111] bg-[#444] ml-4 rounded"></div>
                </div>
            </div>
            
            {/* Name Input Screen - REDESIGNED */}
            {gameState === GameState.NAME_INPUT && (
              <div className="absolute inset-0 bg-black/95 flex flex-col items-center justify-center text-white p-6 z-40 animate-fade-in">
                 {/* Service Update Style Container */}
                 <div className="w-full max-w-xs border-t-8 border-[#E32017] bg-[#111] p-6 shadow-2xl relative">
                    <h2 className="text-2xl font-bold text-white mb-1 tracking-wide uppercase font-tube">{t('IDENTIFICATION')}</h2>
                    <p className="text-xs text-gray-500 uppercase tracking-widest mb-6 border-b border-gray-800 pb-4">{t('ENTER_NAME')}</p>
                    
                    <div className="mb-6">
                        <input 
                           type="text" 
                           value={nameInput}
                           onChange={(e) => setNameInput(e.target.value.toUpperCase().slice(0, 12))}
                           className="w-full bg-black text-white font-tube font-bold text-xl p-3 text-center border border-gray-700 focus:border-white outline-none tracking-wider uppercase rounded"
                           placeholder="DRIVER"
                           autoFocus
                        />
                    </div>
                    
                    <button 
                        onClick={submitName}
                        className="w-full py-3 bg-[#003688] hover:bg-[#002d72] text-white font-bold rounded-full transition transform hover:scale-105 active:scale-95 border-2 border-white/20"
                    >
                        {t('CONFIRM')}
                    </button>
                 </div>
              </div>
            )}

            {gameState === GameState.SPLASH && (
              <div onClick={startIntro} className="absolute inset-0 bg-black/90 flex flex-col items-center justify-center text-white p-6 text-center z-30 cursor-pointer">
                 <div className="mb-8 animate-pulse text-[#003688]"> <svg width="64" height="64" viewBox="0 0 24 24" fill="currentColor"> <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 14.5v-9l6 4.5-6 4.5z"/> </svg> </div>
                 <h1 className="text-2xl font-bold tracking-widest mb-2 font-tube">LONDON UNDERGROUND</h1>
                 <p className="text-sm text-gray-400 uppercase tracking-[0.2em]">{t('ENTER_STATION')}</p>
              </div>
            )}

            {gameState === GameState.START && (
              <div className="absolute inset-0 bg-black/80 flex flex-col items-center justify-center text-white p-6 text-center z-20 animate-fadeInSlow">
                 <button 
                    onClick={() => { setGameState(GameState.SETTINGS); AudioSys.toggle(); }}
                    className="absolute top-4 left-4 bg-gray-800 hover:bg-gray-700 w-10 h-10 rounded-full text-white flex items-center justify-center border border-gray-600 shadow-lg mt-10 z-40"
                 >
                    ‚öôÔ∏è
                 </button>
              
                <div className="mb-4 animate-bounce relative">
                   <div className="w-32 h-32 rounded-full bg-[#E32017] flex items-center justify-center shadow-xl"> <div className="w-20 h-20 rounded-full bg-white"></div> </div>
                   <div className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 w-36 h-8 bg-[#003688] flex items-center justify-center shadow-sm z-10"> <span className="text-white font-bold text-sm tracking-widest font-tube">UNDERGROUND</span> </div>
                </div>
                <h1 className="text-3xl font-bold mb-2 font-['Inter'] tracking-tight">TUBE JUMP</h1>
                
                {/* Loadout Toggles */}
                <div className="flex gap-2 mb-6 h-10">
                    {[ConsumableType.ROCKET, ConsumableType.REVIVE, ConsumableType.DOUBLE_COINS, ConsumableType.LUCKY_CHARM].map(type => {
                        const count = inventory[type] || 0;
                        const active = loadout[type];
                        const itemDef = SHOP_CONSUMABLES.find(i => i.id === type);
                        if (count === 0) return null;
                        return (
                            <button 
                                key={type}
                                onClick={() => toggleLoadoutItem(type)}
                                className={`w-10 h-10 rounded-lg flex items-center justify-center border-2 transition-all ${active ? 'bg-green-600 border-green-400 scale-110' : 'bg-gray-700 border-gray-600 grayscale hover:grayscale-0'}`}
                                title={itemDef.name}
                            >
                                <span className="text-xl">{itemDef.icon}</span>
                                <span className="absolute -top-2 -right-2 bg-red-600 text-white text-[10px] w-4 h-4 rounded-full flex items-center justify-center">{count}</span>
                            </button>
                        );
                    })}
                </div>

                <div className="flex flex-col items-center gap-4 w-full max-w-xs">
                   {/* MAIN ROW: SHOP - PLAY - TASKS */}
                  <div className="flex items-center justify-center gap-4 w-full">
                       {/* SHOP */}
                       <button onClick={() => { setGameState(GameState.SHOP); AudioSys.init(); }} className="w-20 h-20 flex flex-col items-center justify-center bg-gray-700 hover:bg-gray-600 text-white font-bold rounded-xl shadow-lg border-b-4 border-gray-900 active:border-b-0 active:translate-y-1"> 
                        <span className="text-2xl mb-1">üõí</span> 
                        <span className="text-[10px]">{t('SHOP')}</span> 
                      </button>
                      
                      {/* PLAY */}
                      <button onClick={() => handleStartGame()} className="w-28 h-28 flex flex-col items-center justify-center bg-[#003688] hover:bg-[#002d72] text-white font-bold rounded-full shadow-lg shadow-blue-900/50 border-4 border-white scale-110 z-10 font-tube"> 
                        <span className="text-2xl">{t('PLAY')}</span> 
                      </button>

                       {/* TASKS */}
                      <button onClick={() => { setGameState(GameState.MISSIONS); AudioSys.init(); }} className="w-20 h-20 flex flex-col items-center justify-center bg-gray-700 hover:bg-gray-600 text-white font-bold rounded-xl shadow-lg border-b-4 border-gray-900 active:border-b-0 active:translate-y-1"> 
                        <span className="text-2xl mb-1">üìã</span> 
                        <span className="text-[10px]">{t('TASKS')}</span> 
                      </button>
                  </div>
                  
                  {/* BOTTOM ROW: RANKING (CENTERED SQUARE) */}
                   <div className="flex justify-center w-full">
                       <button onClick={() => { setGameState(GameState.RANKING); AudioSys.init(); }} className="w-20 h-20 flex flex-col items-center justify-center bg-gray-700 hover:bg-gray-600 text-white font-bold rounded-xl shadow-lg border-b-4 border-gray-900 active:border-b-0 active:translate-y-1"> 
                             <span className="text-2xl mb-1">üèÜ</span> 
                             <span className="text-[10px]">{t('RANKING')}</span> 
                      </button>
                  </div>
                </div>
              </div>
            )}
            
            {/* NEW: SETTINGS MENU (Task Style) */}
            {gameState === GameState.SETTINGS && (
              <div className="absolute inset-0 bg-black/95 flex flex-col text-white p-4 z-30 animate-fade-in">
                <div className="flex justify-between items-center mb-4 border-b border-gray-700 pb-2">
                    <h2 className="text-2xl font-bold text-yellow-400 font-tube">{t('SERVICE_STATUS')}</h2>
                </div>
                <div className="flex-1 overflow-y-auto space-y-3 pb-4 pr-1">
                    
                    {/* NEW: Audio Toggle Card (Moved from main screen) */}
                     <div className="bg-gray-800 p-3 rounded-lg border border-gray-700">
                        <div className="flex justify-between items-center mb-2"> 
                            <span className="font-bold text-sm text-white">{t('AUDIO')}</span> 
                        </div>
                        <button onClick={toggleMute} className={`w-full py-2 text-xs font-bold rounded border transition-colors ${!isMuted ? 'bg-white text-black border-white' : 'bg-black text-gray-500 border-gray-700'}`}>
                            {isMuted ? `üîá ${t('SOUND')} OFF` : `üîä ${t('SOUND')} ON`}
                        </button>
                    </div>

                    {/* Language Card */}
                    <div className="bg-gray-800 p-3 rounded-lg border border-gray-700">
                        <div className="flex justify-between items-center mb-2"> 
                            <span className="font-bold text-sm text-white">{t('LANGUAGE')}</span> 
                        </div>
                        <div className="flex gap-2">
                            <button onClick={() => setLanguageAndSave('EN')} className={`flex-1 py-2 text-xs font-bold rounded border transition-colors ${language === 'EN' ? 'bg-white text-black border-white' : 'bg-black text-gray-500 border-gray-700 hover:border-gray-500'}`}>ENGLISH</button>
                            <button onClick={() => setLanguageAndSave('DE')} className={`flex-1 py-2 text-xs font-bold rounded border transition-colors ${language === 'DE' ? 'bg-white text-black border-white' : 'bg-black text-gray-500 border-gray-700 hover:border-gray-500'}`}>DEUTSCH</button>
                        </div>
                    </div>

                    {/* Statistics Card */}
                    <div className="bg-gray-800 p-3 rounded-lg border border-gray-700">
                        <div className="flex justify-between items-center mb-2 border-b border-gray-700 pb-1"> 
                            <span className="font-bold text-sm text-white">{t('STATS')}</span> 
                            <span className="text-[10px] text-green-500 bg-green-900/30 px-2 py-0.5 rounded font-tube">OPERATIONAL</span>
                        </div>
                        
                        <div className="space-y-2">
                            <div className="flex justify-between items-center">
                                <div className="flex items-center gap-2">
                                    <div className="w-2 h-2 rounded-full bg-white"></div>
                                    <span className="text-xs text-gray-400">{t('STAT_HEIGHT')}</span>
                                </div>
                                <span className="text-xs font-mono font-bold">{missionStats.totalScore}m</span>
                            </div>
                             <div className="flex justify-between items-center">
                                <div className="flex items-center gap-2">
                                    <div className="w-2 h-2 rounded-full bg-[#FFD700]"></div>
                                    <span className="text-xs text-gray-400">{t('STAT_COINS')}</span>
                                </div>
                                <span className="text-xs font-mono font-bold">{missionStats.totalCoins}</span>
                            </div>
                             <div className="flex justify-between items-center">
                                <div className="flex items-center gap-2">
                                    <div className="w-2 h-2 rounded-full bg-[#003688]"></div>
                                    <span className="text-xs text-gray-400">{t('STAT_JUMPS')}</span>
                                </div>
                                <span className="text-xs font-mono font-bold">{missionStats.totalJumps}</span>
                            </div>
                             <div className="flex justify-between items-center">
                                <div className="flex items-center gap-2">
                                    <div className="w-2 h-2 rounded-full bg-[#E32017]"></div>
                                    <span className="text-xs text-gray-400">{t('STAT_POWERUPS')}</span>
                                </div>
                                <span className="text-xs font-mono font-bold">{missionStats.totalPowerups}</span>
                            </div>
                             <div className="flex justify-between items-center">
                                <div className="flex items-center gap-2">
                                    <div className="w-2 h-2 rounded-full bg-gray-500"></div>
                                    <span className="text-xs text-gray-400">{t('STAT_GAMES')}</span>
                                </div>
                                <span className="text-xs font-mono font-bold">{missionStats.totalGames}</span>
                            </div>
                        </div>
                    </div>

                </div>
                <button onClick={() => { setGameState(GameState.START); AudioSys.playTone(300, 'sine', 0.1); }} className="w-full py-3 bg-[#E32017] font-bold rounded-lg mt-2 border-b-4 border-red-900 active:border-b-0 active:translate-y-1">{t('BACK')}</button>
              </div>
            )}
            
            {gameState === GameState.MISSIONS && (
              <div className="absolute inset-0 bg-black/95 flex flex-col text-white p-4 z-30 animate-fade-in">
                <div className="flex justify-between items-center mb-4 border-b border-gray-700 pb-2"> <h2 className="text-2xl font-bold text-yellow-400 font-tube">{t('SERVICE_TASKS')}</h2> <div className="bg-gray-800 px-3 py-1 rounded-full flex items-center gap-2"> <div className="w-3 h-3 rounded-full bg-[#FFD700]"></div> <span className="font-bold">{coins}</span> </div> </div>
                <div className="flex-1 overflow-y-auto space-y-3 pb-4 pr-1">
                  {Object.keys(MISSION_DEFINITIONS).map(cat => {
                      const tierIdx = missionStats.tiers[cat];
                      const tiers = MISSION_DEFINITIONS[cat];
                      
                      if (tierIdx >= tiers.length) {
                          return (
                            <div key={cat} className="bg-gray-800 p-3 rounded-lg border border-green-900 opacity-75">
                                <div className="flex justify-between items-center mb-1"> <span className="font-bold text-sm text-green-400">{t('MASTERY')} ({cat})</span> </div>
                                <div className="text-xs text-gray-500">{t('ALL_DONE')}</div>
                            </div>
                          );
                      }

                      const mission = tiers[tierIdx];
                      let currentVal = 0;
                      if (cat === MissionCategory.HEIGHT) currentVal = missionStats.totalScore;
                      if (cat === MissionCategory.COINS) currentVal = missionStats.totalCoins;
                      if (cat === MissionCategory.JUMPS) currentVal = missionStats.totalJumps;
                      if (cat === MissionCategory.POWERUPS) currentVal = missionStats.totalPowerups;
                      if (cat === MissionCategory.GAMES) currentVal = missionStats.totalGames;
                      if (cat === MissionCategory.STOPS) currentVal = (missionStats.tiers[MissionCategory.STOPS] * 0) + sessionStatsRef.current.stops; 

                      const pct = Math.min(100, (currentVal / mission.target) * 100);
                      const isComplete = currentVal >= mission.target;

                      return (
                        <div key={cat} className="bg-gray-800 p-3 rounded-lg border border-gray-700">
                            <div className="flex justify-between items-center mb-1"> 
                                <span className="font-bold text-sm">{mission.desc}</span> 
                                <span className="text-[10px] bg-gray-700 px-1 rounded text-gray-400">TIER {tierIdx + 1}/{tiers.length}</span>
                            </div>
                            <div className="flex justify-between items-center mb-2 text-xs">
                                <span className="text-yellow-400 font-bold">{t('REWARD')}: +{mission.reward} üü°</span>
                            </div>
                            <div className="w-full h-2 bg-gray-900 rounded-full overflow-hidden mb-2"> <div className="h-full bg-yellow-500 transition-all duration-500" style={{ width: `${pct}%` }}></div> </div>
                            <div className="flex justify-between items-center"> 
                                <span className="text-xs text-gray-400">{Math.floor(currentVal)} / {mission.target}</span> 
                                <button onClick={() => claimMissionTier(cat)} disabled={!isComplete} className={`px-4 py-1 rounded text-xs font-bold ${isComplete ? 'bg-yellow-500 text-black hover:bg-yellow-400 animate-pulse' : 'bg-gray-700 text-gray-500 cursor-not-allowed'}`} > {isComplete ? t('CLAIM') : t('IN_PROGRESS')} </button> 
                            </div>
                        </div>
                      );
                  })}
                </div>
                <button onClick={() => { setGameState(GameState.START); AudioSys.playTone(300, 'sine', 0.1); }} className="w-full py-3 bg-[#E32017] font-bold rounded-lg mt-2 border-b-4 border-red-900 active:border-b-0 active:translate-y-1">{t('BACK')}</button>
              </div>
            )}

            {gameState === GameState.RANKING && (
              <div className="absolute inset-0 bg-black/95 flex flex-col text-white p-4 z-30 animate-fade-in">
                 <div className="flex justify-between items-center mb-4 border-b border-gray-700 pb-2">
                    <h2 className="text-2xl font-bold text-yellow-400 font-tube">{t('TOP_PASSENGERS')}</h2>
                </div>

                <div className="flex-1 overflow-y-auto space-y-2 pb-4 pr-1">
                    {leaderboard.length === 0 ? <div className="text-yellow-600 text-xs font-mono text-center italic mt-10">{t('SYNCING')}</div> : null}
                    {leaderboard.map((entry, i) => (
                        <div key={i} className={`p-3 rounded-lg border flex items-center justify-between ${entry.player_name === playerName ? 'bg-blue-900/30 border-blue-500' : 'bg-gray-800 border-gray-700'}`}>
                            <div className="flex items-center gap-3">
                                <div className={`w-8 h-8 rounded-full flex items-center justify-center font-bold text-sm shadow-sm ${i===0 ? 'bg-yellow-500 text-black ring-2 ring-yellow-300' : i===1 ? 'bg-gray-400 text-black ring-2 ring-gray-300' : i===2 ? 'bg-orange-700 text-white ring-2 ring-orange-500' : 'bg-gray-700 text-gray-400'}`}>
                                    {i+1}
                                </div>
                                <span className={`font-bold truncate max-w-[150px] ${entry.player_name === playerName ? 'text-white' : 'text-gray-300'}`}>{entry.player_name}</span>
                            </div>
                            {/* CHANGED FONT TO TUBE FONT FOR CLEANER LOOK */}
                            <span className="font-bold text-yellow-400 text-lg font-tube">{entry.score}m</span>
                        </div>
                    ))}
                </div>

                <button onClick={() => { setGameState(GameState.START); AudioSys.playTone(300, 'sine', 0.1); }} className="w-full py-3 bg-[#E32017] font-bold rounded-lg mt-2 border-b-4 border-red-900 active:border-b-0 active:translate-y-1">{t('BACK')}</button>
              </div>
            )}

            {gameState === GameState.TERMINATED_ANIM && (
                <div className="absolute inset-0 flex items-center justify-center bg-black z-40 animate-pulse-red">
                    <div className="text-center">
                        <h1 className="text-5xl font-black tracking-widest border-4 border-current p-4 whitespace-pre-line">{t('SERVICE_TERMINATED')}</h1>
                    </div>
                </div>
            )}

            {gameState === GameState.GAME_OVER && (
              <div className="absolute inset-0 bg-[#050505] flex flex-col items-center justify-center text-white p-6 text-center z-20 animate-fade-in">
                {/* OFFICIAL TUBE GAME OVER UI */}
                <div className="w-full max-w-xs border-t-8 border-[#E32017] bg-[#111] p-6 shadow-2xl relative">
                    <h2 className="text-2xl font-bold text-white mb-1 tracking-wide uppercase font-tube">{t('GAME_OVER_TITLE')}</h2>
                    <p className="text-xs text-gray-500 uppercase tracking-widest mb-6 border-b border-gray-800 pb-4">{t('GAME_OVER_DESC')}</p>
                    
                    <div className="space-y-4 mb-8">
                         <div className="flex justify-between items-end">
                            <span className="text-gray-400 text-xs uppercase font-bold">{t('SCORE')}</span>
                            <span className="text-4xl font-mono font-bold text-white">{score}<span className="text-sm text-gray-600 ml-1">m</span></span>
                        </div>
                         <div className="flex justify-between items-end">
                            <span className="text-gray-400 text-xs uppercase font-bold">{t('BEST')}</span>
                            <span className="text-xl font-mono font-bold text-gray-500">{highScore}</span>
                        </div>
                    </div>
                    
                    <div className="flex items-center justify-center gap-3 mb-8 bg-gray-900 p-3 rounded border border-gray-800">
                        <div className="w-3 h-3 rounded-full bg-[#FFD700]"></div>
                        <span className="text-xl font-bold text-yellow-500 font-mono">+{sessionStatsRef.current.coins}</span>
                    </div>

                    {/* ACTIONS - ROW LAYOUT - WIDER BUTTONS - UPDATED SPACING */}
                    <div className="flex items-center justify-between w-full -mx-4">
                        {/* SHOP (Left Square) - Wider */}
                       <button onClick={() => setGameState(GameState.SHOP)} className="w-20 h-20 flex flex-col items-center justify-center bg-gray-800 hover:bg-gray-700 text-white font-bold rounded-xl shadow-lg border border-gray-700 active:scale-95 transition-all">
                           <span className="text-2xl mb-1">üõí</span> 
                           <span className="text-[10px] uppercase">{t('SHOP')}</span> 
                       </button>
                       
                       {/* TRY AGAIN (Center Roundel) */}
                       <button onClick={() => handleStartGame()} className="w-28 h-28 flex-shrink-0 flex flex-col items-center justify-center bg-[#003688] hover:bg-[#002d72] text-white font-bold rounded-full shadow-lg shadow-blue-900/50 border-4 border-white scale-110 z-10 transition-transform hover:scale-110 active:scale-100 font-tube">
                           <span className="text-sm text-center leading-tight px-2">{t('TRY_AGAIN')}</span>
                       </button>
                       
                       {/* EXIT (Right Square) - Wider */}
                       <button onClick={() => setGameState(GameState.START)} className="w-20 h-20 flex flex-col items-center justify-center bg-gray-800 hover:bg-gray-700 text-white font-bold rounded-xl shadow-lg border border-gray-700 active:scale-95 transition-all">
                           <span className="text-2xl mb-1">üö™</span> 
                           <span className="text-[10px] uppercase">{t('EXIT')}</span> 
                       </button>
                    </div>
                </div>
              </div>
            )}

            {gameState === GameState.SHOP && (
              <div className="absolute inset-0 bg-black/95 flex flex-col text-white p-4 z-30 animate-fade-in">
                <div className="flex justify-between items-center mb-4"> <h2 className="text-2xl font-bold text-yellow-400 font-tube">{t('TICKET_HALL')}</h2> <div className="bg-gray-800 px-3 py-1 rounded-full flex items-center gap-2"> <div className="w-3 h-3 rounded-full bg-[#FFD700]"></div> <span className="font-bold">{coins}</span> </div> </div>
                <div className="flex w-full mb-4 bg-gray-800 rounded-lg p-1"> <button onClick={() => setShopTab('SKINS')} className={`flex-1 py-1 text-xs font-bold rounded-md transition-colors ${shopTab === 'SKINS' ? 'bg-gray-600 text-white' : 'text-gray-400 hover:text-white'}`}>{t('SKINS')}</button> <button onClick={() => setShopTab('ITEMS')} className={`flex-1 py-1 text-xs font-bold rounded-md transition-colors ${shopTab === 'ITEMS' ? 'bg-gray-600 text-white' : 'text-gray-400 hover:text-white'}`}>{t('ITEMS')}</button> </div>
                <div className="flex-1 overflow-y-auto grid grid-cols-2 gap-4 pb-4">
                  {shopTab === 'SKINS' && SHOP_SKINS.map(item => {
                    const isOwned = ownedSkins.includes(item.id); const isEquipped = equippedSkin === item.id;
                    return ( <div key={item.id} className={`p-3 rounded-lg border-2 flex flex-col items-center text-center transition-all ${isEquipped ? 'border-[#009900] bg-[#003300]' : 'border-gray-700 bg-gray-800'} ${!isOwned && coins < item.price ? 'opacity-50' : 'opacity-100'} `}> <div className="w-12 h-12 mb-2 flex items-center justify-center bg-gray-900 rounded-full border border-gray-600"> {item.id === SkinType.NONE && <div className="w-6 h-4 bg-white rounded"></div>} {item.id === SkinType.HARDHAT && <div className="w-8 h-4 bg-yellow-400 rounded-t-lg border-b-2 border-yellow-600"></div>} {item.id === SkinType.TOPHAT && <div className="w-6 h-6 bg-black border-b-4 border-gray-500"></div>} {item.id === SkinType.VIKING && <div className="text-2xl">ü™ñ</div>} {item.id === SkinType.ROYALGUARD && <div className="w-6 h-8 bg-black rounded-t-lg border-b border-yellow-500"></div>} {item.id === SkinType.CROWN && <div className="text-yellow-400 text-xl">üëë</div>} </div> <h3 className="font-bold text-sm">{item.name}</h3> <p className="text-xs text-gray-400 mb-2">{item.desc}</p> {isOwned ? ( <button onClick={() => equipSkin(item.id)} className={`px-3 py-1 rounded text-xs font-bold w-full ${isEquipped ? 'bg-green-600 text-white' : 'bg-gray-600 hover:bg-gray-500'}`} > {isEquipped ? t('EQUIPPED') : t('EQUIP')} </button> ) : ( <button onClick={() => buySkin(item)} disabled={coins < item.price} className="px-3 py-1 rounded text-xs font-bold w-full bg-yellow-600 hover:bg-yellow-500 disabled:bg-gray-700 disabled:text-gray-500" > {t('BUY')} {item.price} </button> )} </div> );
                  })}
                  {shopTab === 'ITEMS' && SHOP_CONSUMABLES.map(item => {
                      const count = inventory[item.id] || 0;
                      return ( <div key={item.id} className="p-3 rounded-lg border-2 border-gray-700 bg-gray-800 flex flex-col items-center text-center"> <div className="w-12 h-12 mb-2 flex items-center justify-center bg-gray-900 rounded-full border border-gray-600 text-2xl"> {item.icon} </div> <h3 className="font-bold text-sm">{item.name}</h3> <p className="text-xs text-gray-400 mb-2">{item.desc}</p> <div className="text-xs text-green-400 font-bold mb-2">{t('OWNED')}: {count}</div> <button onClick={() => buyConsumable(item)} disabled={coins < item.price} className="px-3 py-1 rounded text-xs font-bold w-full bg-blue-600 hover:bg-blue-500 disabled:bg-gray-700 disabled:text-gray-500" > {t('BUY')} {item.price} </button> </div> );
                  })}
                </div>
                <button onClick={() => { setGameState(GameState.START); AudioSys.playTone(300, 'sine', 0.1); }} className="w-full py-3 bg-[#E32017] font-bold rounded-lg mt-2">{t('BACK')}</button>
              </div>
            )}

            {/* NEU: Touch Layer wird nur angezeigt wenn man spielt */}
            {gameState === GameState.PLAYING && (
                <div className="absolute inset-0 flex sm:hidden z-20"> 
                  {/* LEFT CONTROL AREA with VISUAL */}
                  <div 
                    className="w-1/2 h-full flex items-end justify-start p-6 active:bg-white/10 transition-colors pointer-events-auto" 
                    onTouchStart={(e) => { handleTouchStart('left'); }} 
                    onTouchEnd={(e) => { e.preventDefault(); handleTouchEnd(); }}
                  >
                      <div className="bg-white/20 p-4 rounded-full mb-10 ml-2 backdrop-blur-sm border-2 border-white/30">
                        <svg width="32" height="32" viewBox="0 0 24 24" fill="white" className="opacity-80">
                            <path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"/>
                        </svg>
                      </div>
                  </div> 

                  {/* RIGHT CONTROL AREA with VISUAL */}
                  <div 
                    className="w-1/2 h-full flex items-end justify-end p-6 active:bg-white/10 transition-colors pointer-events-auto" 
                    onTouchStart={(e) => { handleTouchStart('right'); }} 
                    onTouchEnd={(e) => { e.preventDefault(); handleTouchEnd(); }}
                  >
                      <div className="bg-white/20 p-4 rounded-full mb-10 mr-2 backdrop-blur-sm border-2 border-white/30">
                        <svg width="32" height="32" viewBox="0 0 24 24" fill="white" className="opacity-80">
                             <path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"/>
                        </svg>
                      </div>
                  </div> 
                </div>
            )}

          </div> 
        );
      };

      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(<GameCanvas />);
    </script>
  </body>
</html>
